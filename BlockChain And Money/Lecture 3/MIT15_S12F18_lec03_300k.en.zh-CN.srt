1
00:00:00,900 --> 00:00:04,440
以下内容是根据知识共享许可提供的

2
00:00:04,450 --> 00:00:10,660
您的支持将帮助 MIT OpenCourseWare 继续免费提供优质教育资源

3
00:00:10,830 --> 00:00:15,290
如果您想捐款或查看数百门麻省理工学院课程的附加材料

4
00:00:15,640 --> 00:00:20,440
请登录 ocw.mit.edu 访问 MIT OpenCourseWare

5
00:00:23,630 --> 00:00:28,270
我只想说，看到你们都还在这里，我非常感动

6
00:00:29,000 --> 00:00:30,080
我真的...

7
00:00:30,080 --> 00:00:36,080
你们知道，在 MIT 的课程中有很多选择机会

8
00:00:36,780 --> 00:00:47,810
你们能回来，而且在阅读中本聪的点对点比特币论文后没有动摇

9
00:00:49,780 --> 00:00:55,150
或者你们只是回来看我是否会在描述它时崩溃掉

10
00:00:56,400 --> 00:01:02,412
但在接下来的三堂课中，先给你们一个印象

11
00:01:02,412 --> 00:01:10,420
我们会通过比特币的视角让您理解区块链的一些技术基础

12
00:01:10,420 --> 00:01:15,080
比特币只是区块链技术的第一个用例

13
00:01:15,780 --> 00:01:19,396
所以如果我说比特币这样或比特币那样

14
00:01:19,396 --> 00:01:24,730
它只是在很大程度上适用于区块链技术，而非完全

15
00:01:25,300 --> 00:01:29,750
我的感觉是... 我只比你们早八九个月

16
00:01:29,840 --> 00:01:36,120
我的职业生涯围绕金融和公共服务

17
00:01:36,150 --> 00:01:40,620
我可以谈论很多有关市场和公共政策的内容

18
00:01:40,640 --> 00:01:45,810
但 MIT 给了我思考区块链技术的礼物

19
00:01:46,320 --> 00:01:49,890
我正在努力将这份礼物回馈一些给你们

20
00:01:50,280 --> 00:01:55,370
房间里有几位计算机科学家，如果我说错了，他们会拯救我

21
00:01:55,650 --> 00:01:59,360
萨布丽娜，然后，我看到阿林正在举起...

22
00:01:59,810 --> 00:02:00,650
你们都认识阿林吗？

23
00:02:00,650 --> 00:02:04,300
他实际上是 MIT 计算机科学系的博士生，所以...

24
00:02:07,620 --> 00:02:11,330
有人已经进入了生活的这一阶段

25
00:02:11,330 --> 00:02:13,416
是的，你说什么？

26
00:02:13,416 --> 00:02:14,518
糟糕的人生选择

27
00:02:14,518 --> 00:02:20,430
糟糕的人生选择，好吧，但他会帮我们解围

28
00:02:20,440 --> 00:02:26,396
但我认为，强调这一点的原因并不仅仅是为了唠叨

29
00:02:26,396 --> 00:02:30,834
而是因为我真的相信，如果所有人都要理解“基本真相”

30
00:02:30,834 --> 00:02:35,880
唯一方法就是了解这项技术的内部运作原理

31
00:02:36,540 --> 00:02:41,420
您不必编写算法或计算哈希函数

32
00:02:41,480 --> 00:02:43,630
但您需要理解他的底层原理

33
00:02:43,680 --> 00:02:48,370
然后你们可以走开，说我不用知道汽车上的化油器是如何工作的

34
00:02:48,390 --> 00:02:50,620
但我知道什么是化油器

35
00:02:50,620 --> 00:02:54,840
或者，任何你想用的比喻

36
00:02:55,740 --> 00:02:58,280
所以，这是一点开场

37
00:02:59,190 --> 00:03:04,467
与我上节课所做的苏格拉底式点名相反

38
00:03:04,467 --> 00:03:09,005
因为金钱，法定货币是核心问题

39
00:03:09,005 --> 00:03:14,480
还有账本，他们是斯隆学生教育或背景的核心

40
00:03:14,870 --> 00:03:19,040
但今天和接下来几堂课的内容不那么核心

41
00:03:19,040 --> 00:03:23,600
在上课过程中，我希望你们在遇到问题的时候随时打断我

42
00:03:24,120 --> 00:03:26,280
我不会非常频繁的点人

43
00:03:26,610 --> 00:03:28,470
但我也不想让你太放松

44
00:03:28,480 --> 00:03:31,950
我还是希望你阅读接下来三堂课的材料

45
00:03:31,960 --> 00:03:37,480
但你可以随时举手，让我停下，然后说“好，但这是什么意思”

46
00:03:37,510 --> 00:03:44,800
这只是... 后面几堂课中我们可以稍微改变一下工作方式

47
00:03:44,800 --> 00:03:48,820
所以，就像我一直会做的，保持一致性

48
00:03:49,610 --> 00:03:51,370
学习问题是什么？

49
00:03:51,380 --> 00:03:54,250
所以，设计特点是什么

50
00:03:54,250 --> 00:03:58,840
区块链这项新技术的主要设计特点是什么

51
00:03:59,150 --> 00:04:01,850
我在教学大纲上列了一些

52
00:04:01,850 --> 00:04:05,480
我们会在今天和下周逐一讨论

53
00:04:05,490 --> 00:04:06,790
包括密码学

54
00:04:06,800 --> 00:04:10,720
仅追加式、时间戳区块

55
00:04:10,860 --> 00:04:14,330
分布式共识算法和网络

56
00:04:14,340 --> 00:04:15,839
我列出了四个

57
00:04:15,839 --> 00:04:20,744
这堂课后面你会看到 8 或 10 个

58
00:04:20,744 --> 00:04:23,420
我想我们会深入挖掘到 10 个

59
00:04:24,460 --> 00:04:26,290
我想简单了解一下课上的情况

60
00:04:26,290 --> 00:04:30,880
不是为了让托莱多或萨布丽娜记录签到

61
00:04:32,390 --> 00:04:33,960
这是一个合理的假设吗？

62
00:04:33,960 --> 00:04:37,900
你们中大多数人或所有人至少读过中本聪的论文？

63
00:04:38,410 --> 00:04:40,540
好的，很好

64
00:04:42,020 --> 00:04:45,790
只是了解一下，你们中有多少人觉得自己至少理解了一半？

65
00:04:45,800 --> 00:04:47,260
可能少于三分之二

66
00:04:47,260 --> 00:04:48,500
但至少有一半

67
00:04:49,720 --> 00:04:51,074
好的，还不错

68
00:04:51,074 --> 00:04:53,825
我第一次读的时候和你们差不多

69
00:04:53,825 --> 00:04:54,681
所以没关系

70
00:04:54,681 --> 00:04:57,033
阿林，你读懂了一半以上，对吧？

71
00:04:57,033 --> 00:04:58,529
我是在五年前读的，所以...

72
00:04:58,529 --> 00:04:59,916
所以你五年前就读过

73
00:04:59,916 --> 00:05:01,950
是的，人生选择

74
00:05:01,950 --> 00:05:02,806
来谈谈它

75
00:05:05,322 --> 00:05:05,700
好吧

76
00:05:07,530 --> 00:05:08,860
而你正在上这门课

77
00:05:09,480 --> 00:05:10,330
好的，很好

78
00:05:12,110 --> 00:05:13,460
所以我们会逐一介绍

79
00:05:13,960 --> 00:05:16,290
然后更具体地说

80
00:05:16,290 --> 00:05:18,940
我们会将密码学抽离出来

81
00:05:19,010 --> 00:05:23,960
两种主要的密码算法

82
00:05:23,960 --> 00:05:27,760
或者您有时会听到的词“加密原语”

83
00:05:28,578 --> 00:05:30,390
阿林，什么是加密原语

84
00:05:30,600 --> 00:05:33,990
哦，那是一群野兽，有很多种

85
00:05:33,990 --> 00:05:36,320
是的，但这两个词放在一起是什么意思？

86
00:05:36,499 --> 00:05:38,655
就像我说的，他可能是任何事物

87
00:05:38,655 --> 00:05:39,210
可以是哈希函数

88
00:05:39,210 --> 00:05:40,630
可以是加密函数

89
00:05:40,630 --> 00:05:42,438
可以是非常强大的计算方案

90
00:05:42,438 --> 00:05:43,858
也可以是数据外包方案

91
00:05:43,858 --> 00:05:46,410
还可以是数据访问隐私方案

92
00:05:46,410 --> 00:05:51,079
但它基本上是可以在对手存在的情况下保护通信的任何技术

93
00:05:51,079 --> 00:05:56,268
嗯，您还可以用它来证明计算在我们不信任的服务器上正确完成

94
00:05:56,268 --> 00:05:58,690
所以这不仅仅是通信，也可以是计算

95
00:05:59,510 --> 00:06:09,650
因此，需要保护或验证的通信和计算都具有某种形式的密码算法

96
00:06:09,650 --> 00:06:11,810
这恰好被称为加密原语

97
00:06:12,160 --> 00:06:14,080
主要有两个

98
00:06:14,160 --> 00:06:16,820
我们将在本学期晚些时候讨论第三个

99
00:06:16,820 --> 00:06:17,840
但主要的两个

100
00:06:18,260 --> 00:06:19,210
哈希函数

101
00:06:20,060 --> 00:06:23,890
作为区块链的工作知识，他们是值得了解的

102
00:06:23,890 --> 00:06:24,820
我们会

103
00:06:24,820 --> 00:06:25,680
我们将会让

104
00:06:25,740 --> 00:06:26,890
每个人都会能够理解

105
00:06:26,900 --> 00:06:30,490
我们会让所有人都对哈希函数有一定的理解

106
00:06:31,060 --> 00:06:33,780
然后是数字签名的完整概念

107
00:06:33,780 --> 00:06:36,590
这与非对称密码学有关

108
00:06:37,030 --> 00:06:42,080
这两者对于区块链技术来说非常基础

109
00:06:42,090 --> 00:06:45,570
学期后期，我们将讨论一些零知识证明

110
00:06:46,250 --> 00:06:50,390
但它们对于一个应用程序来说并不是那么重要

111
00:06:51,030 --> 00:06:53,260
这就是为什么他们，你知道，有点...

112
00:06:53,490 --> 00:06:56,270
它们有助于使事物变得可验证且不可变

113
00:06:56,300 --> 00:06:58,300
这就是商业方面，市场方面

114
00:06:58,300 --> 00:06:59,936
为什么他们很重要

115
00:07:00,300 --> 00:07:04,030
如果不重要的话谁在乎化油器里有什么

116
00:07:05,810 --> 00:07:09,050
那么这一切与双花问题有何关系

117
00:07:09,050 --> 00:07:11,300
我想邀请一位同学，伊莎贝尔

118
00:07:11,310 --> 00:07:14,651
你还记得双花问题是如何产生的吗？

119
00:07:14,651 --> 00:07:18,470
是的，我猜是当用户使用相同的代币

120
00:07:18,480 --> 00:07:22,010
他们会在多个地方，像是在不同的数字钱包中

121
00:07:23,120 --> 00:07:23,970
所以，本质上

122
00:07:23,970 --> 00:07:30,210
双花是指，您拥有一条信息并使用了它两次

123
00:07:30,220 --> 00:07:32,790
现在我们必须称这条信息为金钱

124
00:07:32,800 --> 00:07:34,250
但你用了两次

125
00:07:34,440 --> 00:07:37,430
您可以向两个人发送同一封电子邮件，这没什么

126
00:07:37,870 --> 00:07:39,843
不过，这可能有点尴尬

127
00:07:39,843 --> 00:07:43,260
如果您告诉一位朋友你有时间共进晚餐

128
00:07:43,260 --> 00:07:46,500
而另一个朋友以为你说你没空

129
00:07:46,500 --> 00:07:49,090
但你仍然可以将邮件发给两个人

130
00:07:49,100 --> 00:07:50,830
但在货币体系中

131
00:07:50,840 --> 00:07:54,240
一个关键的问题是你不能重复使用它

132
00:07:55,730 --> 00:07:56,590
阅读材料

133
00:07:58,280 --> 00:07:59,840
哪个模型有帮助吗？

134
00:07:59,880 --> 00:08:02,532
我是说，我们将在这方面做更多

135
00:08:02,532 --> 00:08:05,130
我去年十一、十二月看了那个演示

136
00:08:05,140 --> 00:08:09,120
那是我最早看的东西之一，来自一位 MIT 的学生

137
00:08:09,550 --> 00:08:11,620
我不知道你是否认识这位博斯沃思

138
00:08:12,910 --> 00:08:15,420
我觉得它非常有帮助，所以我很高兴

139
00:08:15,560 --> 00:08:20,310
我看到这个模型在斯坦福大学区块链课程上也有演示

140
00:08:20,530 --> 00:08:25,240
所以在西海岸，我们的竞争对手之一正在使用 MIT 的产品

141
00:08:27,310 --> 00:08:28,730
所以我们会

142
00:08:28,860 --> 00:08:32,620
我们会稍微回顾一下我们在第二课中所做的事情

143
00:08:32,630 --> 00:08:35,670
然后我们将讨论关键的设计特征

144
00:08:35,670 --> 00:08:37,670
正如我前面提到的，哈希函数

145
00:08:37,680 --> 00:08:40,036
什么是仅追加日志

146
00:08:40,036 --> 00:08:43,320
区块头和默克尔树

147
00:08:43,860 --> 00:08:46,450
非对称密码学和数字签名

148
00:08:46,450 --> 00:08:47,010
很疯狂

149
00:08:47,010 --> 00:08:49,200
今天我们将讨论所有的五个

150
00:08:50,990 --> 00:08:53,450
然后你们会告诉我，我们做的如何

151
00:08:53,460 --> 00:08:54,820
哦，还有比特币地址

152
00:08:54,820 --> 00:08:56,010
这只是一件小事

153
00:08:56,010 --> 00:08:57,270
实际上是六件事

154
00:08:58,590 --> 00:09:01,940
所以，对于上次没来的人

155
00:09:01,940 --> 00:09:03,200
我们谈论了货币

156
00:09:03,210 --> 00:09:03,660
再次强调

157
00:09:03,670 --> 00:09:08,360
货币只是一种社会构建，或者说是一种经济共识机制

158
00:09:08,360 --> 00:09:14,510
下周二当我们谈论比特币的共识协议时，我们将详细讨论共识

159
00:09:14,870 --> 00:09:18,070
但要记住，货币本身只是一种共识

160
00:09:18,200 --> 00:09:21,077
周二有人提问

161
00:09:21,890 --> 00:09:24,580
我认为阿林实际上问过这个问题

162
00:09:24,600 --> 00:09:28,160
成为央行的负债意味着什么？

163
00:09:28,160 --> 00:09:29,730
为什么是钱？

164
00:09:29,750 --> 00:09:31,510
这实际上意味着什么？

165
00:09:31,530 --> 00:09:34,150
我说这只是意味着其他人会接受它

166
00:09:34,150 --> 00:09:39,130
这是社会共识，因为他们不会给你任何其他东西

167
00:09:39,410 --> 00:09:41,100
你只是可以拿到一份银行存款

168
00:09:41,100 --> 00:09:42,380
你可以缴纳税款

169
00:09:42,380 --> 00:09:47,650
你可以在星巴克使用它，如果你已经喝了一杯咖啡的话

170
00:09:47,650 --> 00:09:48,670
如果你还记得

171
00:09:48,680 --> 00:09:54,040
它只是债务的法定货币，等等

172
00:09:54,050 --> 00:09:56,470
法定货币只是这长线上的一环

173
00:09:56,880 --> 00:09:59,030
但它曾经面临过挑战和不稳定

174
00:09:59,030 --> 00:10:01,010
这并不意味着它会消失

175
00:10:01,130 --> 00:10:05,450
我不是比特币极大主义者，认为法定货币会消失

176
00:10:05,510 --> 00:10:08,091
但法定货币有其不稳定性

177
00:10:08,091 --> 00:10:12,670
尤其是当世界各地，货币政策疲软

178
00:10:13,260 --> 00:10:17,834
实质上，当你贬值一种货币并允许其大量发行

179
00:10:17,834 --> 00:10:20,440
或者是在不稳定的财政政策下

180
00:10:20,440 --> 00:10:25,875
要么是政府花费很多，像是国王发动对外战争

181
00:10:25,875 --> 00:10:30,480
英格兰银行是在 17 世纪末建立的

182
00:10:30,480 --> 00:10:33,000
实际上，是为了让英国国王在与法国的战争中

183
00:10:33,000 --> 00:10:37,327
控制英格兰的货币，如果我记得没错的话

184
00:10:37,327 --> 00:10:41,437
许多银行，中央银行是在主权国家面临

185
00:10:41,437 --> 00:10:46,462
货币贬值并在战争中花费过多时成立的

186
00:10:46,462 --> 00:10:49,190
我们还讨论了账本

187
00:10:49,190 --> 00:10:51,030
账本有多重要

188
00:10:51,060 --> 00:10:54,950
在本质上，分类账是一种保存记录的方式

189
00:10:55,580 --> 00:10:59,960
这些记录可以是交易记录或余额记录

190
00:10:59,960 --> 00:11:06,420
我们会看到比特币系统被设置为交易分类帐

191
00:11:06,420 --> 00:11:10,310
稍后，我们将讨论其他被设置为余额账本的区块链技术

192
00:11:10,310 --> 00:11:16,560
因此，我们不应该一成不变地认为只有一种方法做到这一点

193
00:11:16,570 --> 00:11:20,930
但交易和账本是比特币的核心

194
00:11:21,450 --> 00:11:24,920
当然，中央银行是建立在分类账上

195
00:11:25,420 --> 00:11:27,250
中央银行有总账

196
00:11:27,250 --> 00:11:30,040
然后商业银行有某种子分类账

197
00:11:30,370 --> 00:11:32,960
然后你有时会想到你的数字钱包

198
00:11:32,970 --> 00:11:35,550
也许星巴克还有第三层账本

199
00:11:36,690 --> 00:11:39,770
显然，我们已经生活在电子时代

200
00:11:39,780 --> 00:11:40,960
我们知道这一点

201
00:11:40,980 --> 00:11:42,580
已经做了很多努力（数字货币）

202
00:11:42,590 --> 00:11:47,720
它们都死了，直到比特币解决了我们谈论的谜题

203
00:11:47,750 --> 00:11:53,290
没有中央机构的点对点货币

204
00:11:53,860 --> 00:11:55,720
在本学期晚些时候，当我们谈论

205
00:11:57,860 --> 00:11:59,630
（区块链）有哪些用例

206
00:12:00,480 --> 00:12:02,090
这将是核心的事情

207
00:12:02,590 --> 00:12:04,370
这是为什么我不是比特币极大主义者

208
00:12:04,370 --> 00:12:07,243
我不确定在任何情况下

209
00:12:07,243 --> 00:12:12,250
中心化的中介都一定是坏事

210
00:12:12,580 --> 00:12:14,130
这不是一个价值判断

211
00:12:14,140 --> 00:12:16,830
这只是纯粹从货币和市场... 等等

212
00:12:17,140 --> 00:12:18,640
但在某些情况下

213
00:12:18,640 --> 00:12:23,200
去中心化确实能与中心化竞争并将其击败

214
00:12:24,200 --> 00:12:28,380
那么我们来谈谈他的小论文

215
00:12:28,770 --> 00:12:32,650
当然，他很谦虚，或者她很谦虚

216
00:12:33,620 --> 00:12:38,808
请提醒我，我们不知道中本聪现在或曾经是谁

217
00:12:38,808 --> 00:12:40,110
或者他/她是一群人

218
00:12:40,120 --> 00:12:43,813
“我一直在开发一种新的电子现金系统”

219
00:12:43,813 --> 00:12:47,130
”该系统完全点对点，无需可信第三方“

220
00:12:49,430 --> 00:12:52,830
你之前看过这张幻灯片

221
00:12:52,840 --> 00:12:55,690
但这是一个带有时间戳的仅追加式日志

222
00:12:55,700 --> 00:12:57,470
想想一块块的数据

223
00:12:57,620 --> 00:12:59,810
虽然这有点过于简单化

224
00:12:59,810 --> 00:13:02,640
但它有一个名字，区块链

225
00:13:03,260 --> 00:13:05,070
我不认为中本聪的论文中...

226
00:13:05,070 --> 00:13:07,130
大家这几天都读了

227
00:13:07,240 --> 00:13:11,660
当然，我昨天再读了一遍，为了确保我还记得

228
00:13:12,030 --> 00:13:14,320
我不记得他用过区块链这个词

229
00:13:14,580 --> 00:13:16,150
我没记错吧？

230
00:13:17,060 --> 00:13:25,350
所以区块链这个词其实有点覆盖了他的创新

231
00:13:25,370 --> 00:13:28,170
因此信息，区块不断添加

232
00:13:28,250 --> 00:13:30,850
基本上，这就形成了一个数据库

233
00:13:31,620 --> 00:13:33,150
但这是数据块

234
00:13:33,520 --> 00:13:37,210
比特币现在大约有 550,000 个区块

235
00:13:37,670 --> 00:13:41,410
平均每10分钟添加一次区块

236
00:13:42,500 --> 00:13:44,760
我们会讨论为什么是每 10 分钟一次

237
00:13:44,810 --> 00:13:49,650
不仅是中本聪为什么设计为 10 分钟

238
00:13:49,660 --> 00:13:51,480
还有他们是如何保持的

239
00:13:51,480 --> 00:13:55,250
其他区块链，比如以太坊大约每 7 秒一次

240
00:13:55,310 --> 00:13:58,300
所以不要认为他们都会是一样的

241
00:13:58,820 --> 00:14:02,650
有一些技术专家，在 MIT

242
00:14:02,670 --> 00:14:05,170
西尔维奥-米卡里正在开发 Algorand

243
00:14:05,380 --> 00:14:08,720
它的时间更短，甚至不到 7 秒

244
00:14:08,730 --> 00:14:11,090
所以不止一种方法

245
00:14:11,100 --> 00:14:14,670
关于区块产生的频率有多种设计

246
00:14:14,870 --> 00:14:16,772
但让我们从比特币开始

247
00:14:17,707 --> 00:14:19,442
安全是通过

248
00:14:19,442 --> 00:14:20,340
是的，你猜怎么着

249
00:14:20,340 --> 00:14:22,530
这两个加密原语来保证的

250
00:14:22,540 --> 00:14:25,090
哈希函数和数字签名

251
00:14:26,940 --> 00:14:28,380
谁开始迷惑了吗？

252
00:14:28,390 --> 00:14:29,960
是吗？可能吧

253
00:14:30,170 --> 00:14:33,990
然后共识以达成一致

254
00:14:34,550 --> 00:14:40,450
通常关于数据库的辩论，是谁可以更改数据

255
00:14:41,470 --> 00:14:44,260
实际上，这对所有数据库都是如此

256
00:14:44,260 --> 00:14:45,780
它通常是中心化的

257
00:14:45,920 --> 00:14:46,750
但在区块链中

258
00:14:46,750 --> 00:14:47,510
突然之间

259
00:14:47,640 --> 00:14:49,330
也许数据库不是中心化的了

260
00:14:49,340 --> 00:14:53,042
谁可以添加下一条信息，下一个区块

261
00:14:53,042 --> 00:14:58,510
我们下周二要讨论的共识协议就是关于这个问题的

262
00:14:59,240 --> 00:15:03,870
我想之前有张漂亮的幻灯片展示了这一点

263
00:15:03,880 --> 00:15:07,540
但我打算把讨论推迟到下周二

264
00:15:07,950 --> 00:15:09,680
希望你们都能回来

265
00:15:10,260 --> 00:15:12,710
那么主要特征是什么

266
00:15:13,380 --> 00:15:15,400
我可能会”邀请“一位同学

267
00:15:15,510 --> 00:15:19,480
你还记得论文提到的关键特征吗？汤姆

268
00:15:20,330 --> 00:15:21,203
噢，天哪

269
00:15:22,120 --> 00:15:22,772
没关系

270
00:15:22,772 --> 00:15:24,540
呃，哈希函数

271
00:15:24,540 --> 00:15:26,620
哈希函数，还有别的关键特征吗？

272
00:15:26,620 --> 00:15:29,000
让我们看看有多少，这一页上会有 10 个

273
00:15:29,530 --> 00:15:31,350
公钥和私钥

274
00:15:31,530 --> 00:15:32,180
是什么？

275
00:15:32,310 --> 00:15:33,800
私钥公钥

276
00:15:35,530 --> 00:15:36,550
私钥和公钥

277
00:15:36,560 --> 00:15:40,420
是的，非对称密码学，或者私钥和公钥

278
00:15:40,920 --> 00:15:42,100
是的，散列函数

279
00:15:42,100 --> 00:15:43,360
还有私钥公钥

280
00:15:43,430 --> 00:15:48,780
还有其他关键特征吗？或者你不理解的词语

281
00:15:48,780 --> 00:15:50,030
也许这是另一种表达方式

282
00:15:51,140 --> 00:15:51,968
里安卓

283
00:15:51,968 --> 00:15:52,768
地址

284
00:15:52,768 --> 00:15:55,040
是什么？地址，比特币账户地址

285
00:15:55,050 --> 00:15:55,700
3 个

286
00:15:55,905 --> 00:15:57,473
时间戳服务器

287
00:15:57,473 --> 00:15:59,542
时间戳服务器，4 件事了

288
00:15:59,542 --> 00:16:00,570
我们进展不错

289
00:16:01,420 --> 00:16:04,010
里汉姆? -- 双花

290
00:16:04,010 --> 00:16:08,950
双花是比特币试图解决的问题

291
00:16:08,960 --> 00:16:10,700
这不是设计功能

292
00:16:10,700 --> 00:16:13,250
但这是... 他们有双花问题的解决方案

293
00:16:13,510 --> 00:16:14,540
我会给你加一分

294
00:16:14,550 --> 00:16:15,110
但它是...

295
00:16:17,270 --> 00:16:20,296
好的，雨果提到了矿工

296
00:16:20,296 --> 00:16:22,100
这是共识真正...

297
00:16:22,100 --> 00:16:26,989
我会说设计特征是共识或工作量证明

298
00:16:27,403 --> 00:16:29,980
凯莉？-- 全节点与轻节点

299
00:16:30,670 --> 00:16:34,110
很好，节点的概念很有意思

300
00:16:34,110 --> 00:16:38,450
中本聪实际上提到了全节点和轻节点

301
00:16:38,450 --> 00:16:41,860
这实际上是关于需要存储多少信息

302
00:16:41,870 --> 00:16:43,270
我想保留这个问题，凯莉

303
00:16:43,270 --> 00:16:46,970
当我们谈论区块头时，请提醒我回到这个话题

304
00:16:46,970 --> 00:16:52,000
但节点和网络是非常重要的设计特征  这里？

305
00:16:52,330 --> 00:16:53,696
默克尔树结构

306
00:16:54,363 --> 00:16:55,750
默克尔树结构

307
00:16:55,798 --> 00:16:57,340
默克尔树结构

308
00:16:57,430 --> 00:17:01,704
默克尔树结构是一种压缩大量数据的方法

309
00:17:02,438 --> 00:17:04,874
并且还可以对这些数据进行排序

310
00:17:04,874 --> 00:17:08,277
糟糕，哦没事，萨布丽娜不会在这里把我赶走

311
00:17:08,277 --> 00:17:10,291
默克尔树结构，在那里

312
00:17:10,291 --> 00:17:11,814
我们会讨论这个，再来两个

313
00:17:12,257 --> 00:17:13,149
Nonce

314
00:17:13,149 --> 00:17:13,849
什么？

315
00:17:13,849 --> 00:17:14,469
Nonce

316
00:17:14,469 --> 00:17:16,986
节点，好吧，什么？

317
00:17:16,986 --> 00:17:19,155
Nonce，好的

318
00:17:19,155 --> 00:17:20,860
所以有一个Nonce

319
00:17:20,860 --> 00:17:22,525
谁知道 Nonce 这个词是什么？

320
00:17:22,525 --> 00:17:24,610
一年前我还不知道

321
00:17:24,830 --> 00:17:26,500
所以你看... 我们都会到达哪里

322
00:17:29,390 --> 00:17:31,210
让我看看

323
00:17:31,220 --> 00:17:32,968
你知道什么是 Nonce 吗？不知道

324
00:17:34,340 --> 00:17:35,959
在实际协议中

325
00:17:35,959 --> 00:17:38,590
这本质上是矿工所做一种的猜测

326
00:17:39,180 --> 00:17:43,779
所以 Nonce 这个词的意思是一个只用一次的随机数

327
00:17:43,779 --> 00:17:44,950
N 代表数字

328
00:17:46,800 --> 00:17:48,084
然后一次（once）

329
00:17:48,617 --> 00:17:51,460
它是一个随机且只用一次的数字

330
00:17:53,280 --> 00:17:54,800
我就是这样学会的

331
00:17:57,450 --> 00:18:01,370
那么，再来一个，这样真是太棒了

332
00:18:01,790 --> 00:18:02,565
点对点

333
00:18:02,565 --> 00:18:03,699
告诉我你的名字

334
00:18:03,699 --> 00:18:04,416
克莉亚

335
00:18:04,416 --> 00:18:05,730
克莉亚，点对点

336
00:18:06,410 --> 00:18:07,540
好的，那么...

337
00:18:07,550 --> 00:18:10,240
这是我们有的，密码学哈希函数

338
00:18:10,250 --> 00:18:13,042
我们会更详细地讨论这些

339
00:18:13,042 --> 00:18:15,644
带时间戳的仅追加式日志

340
00:18:16,145 --> 00:18:18,460
区块头和默克尔树

341
00:18:18,470 --> 00:18:20,010
所以我们讨论了默克尔树

342
00:18:20,020 --> 00:18:27,323
但我们需要实际知道，与主体信息相比，哪些被保存在区块头

343
00:18:27,323 --> 00:18:31,690
这其中有些只是为了使其更易于管理

344
00:18:32,120 --> 00:18:33,720
非对称密码学

345
00:18:33,720 --> 00:18:36,670
即公钥、私钥和签名

346
00:18:38,130 --> 00:18:40,250
比特币地址本身

347
00:18:40,970 --> 00:18:44,720
有趣的是它们与公钥略有不同

348
00:18:45,090 --> 00:18:50,913
然后我中断一下，因为下一个我们会在下周二讨论

349
00:18:50,913 --> 00:18:52,715
工作量证明、矿工

350
00:18:52,715 --> 00:18:55,818
节点、随机数等

351
00:18:55,818 --> 00:18:58,350
他们都属于哪个小主题

352
00:18:59,440 --> 00:19:03,559
比特币里其实有一个非常重要的协议

353
00:19:03,559 --> 00:19:06,340
是信息如何在互联网上传播

354
00:19:06,350 --> 00:19:09,700
它只是网络通讯，论文中没有写太多

355
00:19:09,800 --> 00:19:13,569
你不会在纳撒尼尔-波普尔的《数字黄金》或其他流行书籍中

356
00:19:13,569 --> 00:19:15,120
读到很多关于这个的内容

357
00:19:15,200 --> 00:19:17,907
但重要的是我们要提醒自己

358
00:19:17,907 --> 00:19:25,290
信息必须在互联网上传播，所有这些交易必须相互通信

359
00:19:25,300 --> 00:19:30,390
目前比特币网络上约有 10,000 个节点

360
00:19:30,400 --> 00:19:32,290
我们不知道它们都在哪里

361
00:19:32,290 --> 00:19:34,980
但他们可能分布在 180 个不同的国家

362
00:19:35,460 --> 00:19:40,070
所以这是... 网络和沟通也很重要

363
00:19:40,430 --> 00:19:42,820
这对经济非常重要

364
00:19:44,060 --> 00:19:45,360
有一种原生货币

365
00:19:45,360 --> 00:19:48,504
有趣的是，这是一件没什么人说的事情

366
00:19:48,504 --> 00:19:52,770
这是实际技术设计中的一项特征

367
00:19:52,780 --> 00:19:55,630
不仅仅是他创造了一种货币

368
00:19:55,730 --> 00:19:59,720
而且原生货币是经济激励系统的一部分

369
00:20:00,520 --> 00:20:03,210
我们将对此进行一些有趣的探讨

370
00:20:03,250 --> 00:20:04,720
实际上，他（中本聪）说

371
00:20:04,720 --> 00:20:08,557
当你挖矿并完成工作量证明时

372
00:20:08,557 --> 00:20:12,640
你就创造并获得了一些叫做比特币的原生货币

373
00:20:12,650 --> 00:20:15,320
于是他创造了一个经济激励制度

374
00:20:15,770 --> 00:20:21,690
无论中本聪过去或现在是谁，他/她都对经济和技术了解很多

375
00:20:21,700 --> 00:20:22,180
是的

376
00:20:22,190 --> 00:20:24,160
我只是想快速补充一下你所说的内容

377
00:20:24,160 --> 00:20:26,820
所以你不仅创造了这个原生货币

378
00:20:26,820 --> 00:20:28,950
而一旦供应量达到上线

379
00:20:28,990 --> 00:20:31,900
该货币可以作为交易费进行分配

380
00:20:32,280 --> 00:20:34,750
我认为这是一个非常重要并值得注意的...

381
00:20:34,750 --> 00:20:35,970
你的名字是？

382
00:20:35,970 --> 00:20:36,530
丹尼尔

383
00:20:36,530 --> 00:20:39,870
所以丹尼尔刚才说的话真的很有趣

384
00:20:39,870 --> 00:20:45,050
不仅要考虑这样做的一个或多个个人

385
00:20:45,380 --> 00:20:56,830
比特币和其他加密货币的世界还创造了一种可以估值的记账单位

386
00:20:56,830 --> 00:21:00,340
一旦它被估值，你就拥有了一种原生货币

387
00:21:00,380 --> 00:21:01,960
但正如丹尼尔所说

388
00:21:01,980 --> 00:21:04,760
中本聪也说过，（比特币总额）会有一个限制

389
00:21:06,130 --> 00:21:11,200
比特币的上限是 2,100 万

390
00:21:11,200 --> 00:21:14,130
我们将在 2040 年左右达到这个数字

391
00:21:14,950 --> 00:21:17,350
有谁知道现在有多少比特币？

392
00:21:17,720 --> 00:21:19,060
你们中大约一半的人在投资

393
00:21:19,170 --> 00:21:20,362
这就是我好奇的原因

394
00:21:20,362 --> 00:21:21,397
休？雨果？

395
00:21:21,397 --> 00:21:24,110
大约 1,700 万比特币

396
00:21:25,300 --> 00:21:31,110
所有的这 1,700 万都来自工作量证明和挖矿过程

397
00:21:31,160 --> 00:21:34,840
最初每 10 分钟有 50 个比特币

398
00:21:35,040 --> 00:21:36,870
大约每 10 分钟

399
00:21:36,880 --> 00:21:39,450
然后，下降到 25 个

400
00:21:39,460 --> 00:21:41,760
我们现在是 12.5 个比特币

401
00:21:42,150 --> 00:21:45,550
有谁知道比特币今天所谓的价值是多少？

402
00:21:45,550 --> 00:21:47,623
我应该说比特币所谓的价值

403
00:21:47,623 --> 00:21:52,040
因为我不知道我们是否可以相信那些标明其价值的网站

404
00:21:53,280 --> 00:21:54,220
什么，是多少？

405
00:21:54,670 --> 00:21:57,310
所以一个比特币 6,500 美元

406
00:21:57,420 --> 00:22:00,590
挖出一个区块有 12.5 个比特币

407
00:22:02,640 --> 00:22:12,260
所以你看，开采一个区块的奖励大约是 80,000 美元

408
00:22:12,300 --> 00:22:12,810
对吧

409
00:22:13,340 --> 00:22:16,318
所以他创建了一个激励系统

410
00:22:16,318 --> 00:22:18,487
最初，如果你有 50 个比特币

411
00:22:18,487 --> 00:22:23,500
而它们一文不值，你就不会投入那么多

412
00:22:24,060 --> 00:22:27,429
在 2009 年，你必须得是个业余爱好者

413
00:22:27,429 --> 00:22:31,900
或者一个赛博朋克，或者对此有些好奇

414
00:22:31,900 --> 00:22:34,403
因为你不会获得多少回报

415
00:22:34,403 --> 00:22:36,760
如果它今天的价值是 6,500 美元

416
00:22:36,760 --> 00:22:38,770
你将获得 80,000 美元

417
00:22:39,570 --> 00:22:42,570
如果你真的成功开采了一个区块

418
00:22:43,690 --> 00:22:46,350
然后是交易输入和输出

419
00:22:46,350 --> 00:22:48,100
想想一张支票

420
00:22:48,870 --> 00:22:52,070
谁签的名，钱在哪里流动

421
00:22:53,210 --> 00:22:55,960
有一种东西叫做“未支出交易分类账”

422
00:22:55,960 --> 00:22:57,550
这是账本部分

423
00:22:57,740 --> 00:23:00,530
所以当你想到... 当我想到技术时

424
00:23:00,570 --> 00:23:02,160
我想到了密码学

425
00:23:02,170 --> 00:23:06,170
这在我们今天将要讨论的所有事情的顶层

426
00:23:06,960 --> 00:23:09,500
第二，共识机制

427
00:23:09,510 --> 00:23:13,040
实际上，这是任何数据库的关键问题

428
00:23:13,280 --> 00:23:15,590
谁有权修改数据库？

429
00:23:15,600 --> 00:23:22,140
谁能决定改变我们都同意的状态？

430
00:23:23,100 --> 00:23:24,420
进而，第三点

431
00:23:24,440 --> 00:23:26,900
是账本或交易账本

432
00:23:26,900 --> 00:23:30,130
我们不会深入研究脚本语言

433
00:23:30,130 --> 00:23:35,000
但下周四，我们会稍微谈谈底层脚本

434
00:23:35,010 --> 00:23:36,250
这是否给了你们一个思路

435
00:23:36,260 --> 00:23:40,920
关于密码学、共识

436
00:23:40,940 --> 00:23:42,180
然后是交易

437
00:23:42,190 --> 00:23:42,620
请说

438
00:23:42,630 --> 00:23:45,640
我有个问题 -- 你的名字是？希望大家都说一下名字

439
00:23:45,660 --> 00:23:46,970
哦，我只是好奇

440
00:23:47,280 --> 00:23:48,277
所以你提到...

441
00:23:48,277 --> 00:23:49,860
我对你的名字很好奇

442
00:23:49,860 --> 00:23:52,014
好吧，我叫肖恩

443
00:23:52,014 --> 00:23:52,591
好的

444
00:23:52,591 --> 00:23:53,680
所以，只是好奇

445
00:23:53,680 --> 00:23:59,321
你提到了截至目前，每个区块的价值约为 80,000 美元

446
00:23:59,321 --> 00:24:00,113
只是好奇

447
00:24:00,311 --> 00:24:05,655
就 CPU 能力而言，挖矿所消耗的电力

448
00:24:05,655 --> 00:24:09,020
换算成等值美元是多少？

449
00:24:10,060 --> 00:24:20,270
所以问题是，矿工为了获得的奖励所耗费的电力是多少

450
00:24:20,270 --> 00:24:21,740
那 80,000 美元

451
00:24:21,750 --> 00:24:25,110
我会尝试用一分钟内回答

452
00:24:25,120 --> 00:24:29,685
但我们将在本学期晚些时候再讨论经济学

453
00:24:29,685 --> 00:24:32,120
区块链经济学和采矿经济学

454
00:24:32,120 --> 00:24:35,290
但这十年来发生的事情是

455
00:24:35,290 --> 00:24:44,550
越来越多的计算机正在尝试挖掘比特币

456
00:24:45,020 --> 00:24:49,571
所以今天，在我最近看到的研究中

457
00:24:49,571 --> 00:24:53,190
赢得一个区块的概率

458
00:24:53,220 --> 00:24:57,320
非常多... 是用“千亿哈希“来衡量的吗？

459
00:24:57,320 --> 00:24:59,440
我不记得准确数字了

460
00:24:59,440 --> 00:25:04,152
但是，是多少个千亿哈希？

461
00:25:04,152 --> 00:25:10,460
千亿哈希是 15 个零吗？还是 12 个？

462
00:25:10,460 --> 00:25:14,229
无论如何，每秒都有如此多的哈希运算

463
00:25:14,229 --> 00:25:19,040
x个千亿哈希，你获胜的概率相当低

464
00:25:19,060 --> 00:25:26,370
因此，大多数节点和矿工都签订了协议，称为矿池

465
00:25:26,380 --> 00:25:30,680
他们借此平摊风险，分享奖励

466
00:25:31,030 --> 00:25:35,384
但我们接下来会谈论的经济学认为

467
00:25:35,384 --> 00:25:40,640
你需要每千瓦时 3 美分左右的电费才能盈利

468
00:25:40,820 --> 00:25:42,250
但在世界大部分地区

469
00:25:42,250 --> 00:25:46,000
你无法以每千瓦时 3 美分的价格获得电力

470
00:25:46,020 --> 00:25:51,066
因此，您可以将采矿设备放置在可以获得低成本电力

471
00:25:51,066 --> 00:25:55,390
或你有可能...

472
00:25:55,390 --> 00:25:59,200
你有可能合法或非法的获得低成本的电力的地方

473
00:25:59,210 --> 00:26:01,743
所以有很多采矿设备

474
00:26:01,743 --> 00:26:07,616
在地方官员允许这些设备采矿的司法管辖区

475
00:26:07,616 --> 00:26:10,060
而不必向电力公司支付每千瓦时 3 美分的费用

476
00:26:10,060 --> 00:26:13,910
对于当地政府官员来说，可能是每千瓦时 1 到 2 美分

477
00:26:14,880 --> 00:26:15,700
所以...

478
00:26:15,780 --> 00:26:18,780
最大的两个矿池都在中国

479
00:26:18,780 --> 00:26:20,790
第三个是在俄罗斯

480
00:26:21,640 --> 00:26:24,230
但我们从经济学的角度

481
00:26:24,230 --> 00:26:28,770
至少一些理论角度，来解释为什么有些矿池位于现在的位置

482
00:26:30,405 --> 00:26:31,850
现在，密码学

483
00:26:33,220 --> 00:26:35,230
阿林可能会帮我整理一下

484
00:26:35,240 --> 00:26:38,310
这不仅是在对手存在时的交流

485
00:26:38,310 --> 00:26:42,317
也包括在对手存在时的计算

486
00:26:42,317 --> 00:26:44,150
对吧？好的

487
00:26:44,150 --> 00:26:45,140
我们谈到了...

488
00:26:45,430 --> 00:26:47,200
我们不会很深入

489
00:26:47,210 --> 00:26:48,370
如果你还记得

490
00:26:48,380 --> 00:26:49,850
即使在古代

491
00:26:49,850 --> 00:26:51,310
如果你要去打仗

492
00:26:51,380 --> 00:26:54,880
有一种奇妙的小方法可以让你使用密码学

493
00:26:54,920 --> 00:27:00,340
然后任何看过《模仿游戏》的人，对

494
00:27:00,920 --> 00:27:06,441
关于英国人，你知道，攻破德国密码

495
00:27:06,441 --> 00:27:10,879
尽管他们应该更多的归功于波兰政府

496
00:27:10,879 --> 00:27:15,430
他们在 1930 年代就成功了，但图灵做的很好

497
00:27:16,010 --> 00:27:18,820
然后今天我们要讨论非对称密码学

498
00:27:20,340 --> 00:27:20,700
好的

499
00:27:20,710 --> 00:27:22,280
什么是哈希函数

500
00:27:23,680 --> 00:27:28,030
哈希函数，这只是我的想法

501
00:27:28,040 --> 00:27:30,400
我认为它是数据的指纹

502
00:27:32,790 --> 00:27:34,720
但它有一定的特性

503
00:27:35,400 --> 00:27:40,640
您将看到的一个特性是，它接受一个输入，称为X

504
00:27:41,210 --> 00:27:45,470
然后它将任意大小的输入映射到固定大小的输出

505
00:27:45,910 --> 00:27:51,430
在美国，我们都在使用的一个哈希函数是邮政编码

506
00:27:51,690 --> 00:27:53,650
5 位数字，这是一个固定的大小

507
00:27:53,650 --> 00:27:56,009
我知道，我只是随便说说

508
00:27:56,009 --> 00:27:58,226
你知道，我怎么想到的呢？

509
00:27:58,226 --> 00:27:59,661
但是，邮政编码

510
00:27:59,661 --> 00:28:05,970
可能有 50,000 或 5,000 人都居住在一个邮政区中

511
00:28:05,980 --> 00:28:07,990
你可以将他们映射到邮政编码

512
00:28:07,990 --> 00:28:09,840
这是一个固定的集合

513
00:28:10,770 --> 00:28:14,560
现在，我不知道计算机系的朋友们有没有...

514
00:28:14,560 --> 00:28:18,090
但这是哈希函数的初步印象

515
00:28:18,110 --> 00:28:20,330
我只是想说... 有些

516
00:28:20,330 --> 00:28:24,252
我们生活中有些实际的事物就像哈希函数一样

517
00:28:24,252 --> 00:28:29,250
邮政编码的问题是，它无法成为安全的哈希函数

518
00:28:29,260 --> 00:28:31,080
你马上就会看到这一点

519
00:28:31,090 --> 00:28:32,330
但这确实需要...

520
00:28:32,730 --> 00:28:36,465
你可以是一个体重 300 磅的成人

521
00:28:36,465 --> 00:28:39,400
也可以是一个体重 30 磅的小孩

522
00:28:39,400 --> 00:28:42,640
但你们会被映射到相同的邮政编码

523
00:28:45,220 --> 00:28:47,850
这是确定性的，总是一样的

524
00:28:47,850 --> 00:28:49,820
所以如果你使用一组特定的数据

525
00:28:50,670 --> 00:28:53,014
它总是会给你相同的哈希值

526
00:28:53,014 --> 00:28:56,900
这与它的背景相关

527
00:28:58,070 --> 00:28:59,630
你可以高效地计算它

528
00:28:59,640 --> 00:29:01,360
你不想花一年的时间来做这件事

529
00:29:01,360 --> 00:29:04,110
你必须在短时间内完成

530
00:29:04,120 --> 00:29:09,431
就比特币而言，它是在纳秒或更短的时间内完成的

531
00:29:09,431 --> 00:29:13,435
因为一台计算机，一个 CPU 就可以完成

532
00:29:13,435 --> 00:29:18,273
记不清了，大概... 是多少？几百万每秒？

533
00:29:18,273 --> 00:29:19,980
每秒几千亿次哈希

534
00:29:19,980 --> 00:29:22,750
每秒进行几千亿次哈希

535
00:29:23,300 --> 00:29:27,010
所以这是一个非常高效的算法

536
00:29:27,930 --> 00:29:33,880
一群数学家... 哈希函数始于上世纪五六十年代

537
00:29:33,880 --> 00:29:37,030
但我们在这里讨论的都是最近的（哈希函数）

538
00:29:37,040 --> 00:29:43,899
但这确实是非常有才华的科学家、数学家、计算机科学家

539
00:29:43,899 --> 00:29:47,600
有时还有美国国家技术标准研究所

540
00:29:47,650 --> 00:29:49,150
在研究哈希函数

541
00:29:49,780 --> 00:29:52,800
所以它接收一个任意大小的数组

542
00:29:52,920 --> 00:29:54,420
把它变成一个固定的数字

543
00:29:54,430 --> 00:29:56,130
我想到了邮政编码

544
00:29:57,420 --> 00:29:59,648
这是确定性的，你总会...

545
00:29:59,648 --> 00:30:02,530
从某种意义上说，你只住在一个邮政编码区

546
00:30:02,540 --> 00:30:04,010
而且他的效率非常高

547
00:30:04,270 --> 00:30:06,955
但现在，哈希函数的加密属性是什么

548
00:30:06,955 --> 00:30:09,980
因为邮政编码达不到我们的目的，它就是不行

549
00:30:11,140 --> 00:30:15,510
计算机科学家使用术语是“原像抵抗”

550
00:30:15,510 --> 00:30:17,570
我想说这是单向的

551
00:30:18,580 --> 00:30:19,720
你只能往一个方向

552
00:30:19,720 --> 00:30:26,360
意味着根据输出确定输入是不可行的

553
00:30:26,700 --> 00:30:30,830
通过 x 的哈希值确定 x 是不可行的

554
00:30:32,850 --> 00:30:36,960
有谁知道为什么我说“不可行”而不是“不可能”？

555
00:30:38,030 --> 00:30:39,187
Brotish -- 名字？

556
00:30:39,187 --> 00:30:40,510
Brotish -- Brotish

557
00:30:41,040 --> 00:30:43,490
因为你可以用暴力来破解它

558
00:30:44,170 --> 00:30:46,160
所以你可以使用暴力的方式做到

559
00:30:46,170 --> 00:30:47,180
你说的暴力是什么意思?

560
00:30:47,180 --> 00:30:48,129
这样大家...

561
00:30:48,129 --> 00:30:50,310
穷举 -- 尝试所有的选择

562
00:30:53,390 --> 00:30:58,039
据我了解，几个世纪以来密码学的基本原则

563
00:30:58,039 --> 00:31:03,190
不在于让它成为数学上不可能的事情

564
00:31:03,200 --> 00:31:11,750
关键是让其变为不可行，比如让你的对手无法获得通信等等

565
00:31:12,130 --> 00:31:13,690
所以哈希函数

566
00:31:13,750 --> 00:31:17,910
我这么说只是因为你不能假设比特币不能被破坏

567
00:31:17,910 --> 00:31:19,250
我们都称其为不可变的

568
00:31:19,250 --> 00:31:27,150
它会是不可变的，直到比特币所用的哈希函数被破坏了

569
00:31:27,160 --> 00:31:30,030
甚至中本聪在 2010 年也写过这方面的内容

570
00:31:30,030 --> 00:31:30,980
他收到一封邮件

571
00:31:30,980 --> 00:31:36,990
我在教学大纲结尾处提到过一本很棒的书，如果你们感兴趣的话

572
00:31:36,990 --> 00:31:42,260
他说：如果SHA-256，比特币所用的哈希函数被破解了怎么办？

573
00:31:42,530 --> 00:31:49,030
中本聪的回答是：到时候会有更好的哈希函数

574
00:31:49,040 --> 00:31:50,370
不管那是什么函数

575
00:31:51,520 --> 00:31:54,350
我们会对整个系统做哈希

576
00:31:54,350 --> 00:31:55,340
不管系统那时怎么样

577
00:31:55,340 --> 00:31:58,050
因为，还记得的话，你可以用任何大小的东西

578
00:31:58,070 --> 00:32:01,150
使用新函数对系统进行哈希处理，然后继续前进

579
00:32:01,150 --> 00:32:05,407
所以他觉得，他或她，在这封精彩的电子邮件中的观点是

580
00:32:05,407 --> 00:32:11,379
比特币实际上可以过渡到新的哈希函数

581
00:32:11,379 --> 00:32:17,190
只要你在比特币系统崩溃之前有一点时间

582
00:32:17,880 --> 00:32:18,300
凯莉？

583
00:32:18,300 --> 00:32:22,850
这就是中本聪文章中的“赌徒毁灭问题”吗？

584
00:32:22,860 --> 00:32:24,640
这是你所描述的吗？

585
00:32:24,840 --> 00:32:26,940
赌徒毁灭问题

586
00:32:26,980 --> 00:32:31,410
攻击者赶上，然后重新构建它的概率

587
00:32:34,020 --> 00:32:35,732
不，那是别的事

588
00:32:35,732 --> 00:32:36,160
那是...

589
00:32:36,670 --> 00:32:38,630
你可以大点声吗？

590
00:32:38,630 --> 00:32:39,610
好的，所以这是

591
00:32:40,010 --> 00:32:41,318
如果我记得没错

592
00:32:41,318 --> 00:32:45,680
你说的是为比特币创建分叉有多难

593
00:32:45,680 --> 00:32:46,925
如果我有很强的计算能力

594
00:32:46,925 --> 00:32:48,981
创建一个分叉对我来说有多难

595
00:32:48,981 --> 00:32:52,159
但是中本聪在论文末尾没有分析这个

596
00:32:52,159 --> 00:32:53,467
哦，抱歉

597
00:32:53,467 --> 00:32:55,150
你说的是他的论文

598
00:32:55,440 --> 00:32:56,820
是的，在他的论文中

599
00:32:56,820 --> 00:33:02,831
他谈到了要进行所谓的 51% 攻击的计算难度

600
00:33:02,831 --> 00:33:05,410
基本上要接管所有节点

601
00:33:05,490 --> 00:33:08,500
我们会在下周二讨论他论文的那部分

602
00:33:08,500 --> 00:33:11,220
但这基本上是，你能控制节点吗？

603
00:33:12,010 --> 00:33:13,550
我谈论的是另一件事

604
00:33:13,550 --> 00:33:15,420
你能破解密码学吗？

605
00:33:15,550 --> 00:33:17,420
他在论文中没有写到这一点

606
00:33:17,420 --> 00:33:21,340
大约 10 个月后，他在一封电子邮件中写下了这件事

607
00:33:22,510 --> 00:33:24,850
密码学的第二个关键

608
00:33:24,850 --> 00:33:27,088
我们说，第一是这是单向的

609
00:33:27,088 --> 00:33:32,110
另一件是抗碰撞的概念

610
00:33:33,050 --> 00:33:36,910
我想，如果这个房间里的每个人都告诉我你的生日

611
00:33:36,930 --> 00:33:40,110
这个房间里会有很多人生日相同

612
00:33:41,230 --> 00:33:41,910
而事实上

613
00:33:41,910 --> 00:33:44,410
如果我们房间有多于 26 人

614
00:33:44,410 --> 00:33:48,650
就有超过 50% 的概率，有两个人生日相同

615
00:33:48,650 --> 00:33:52,190
我们不需要让房间里有 183 个人

616
00:33:52,860 --> 00:33:54,850
这是一年一半天数

617
00:33:54,850 --> 00:33:57,130
我们只需要大约 26 或 27

618
00:34:01,120 --> 00:34:04,359
同样，最关键的是

619
00:34:04,359 --> 00:34:11,600
两组数据，X 和 Y 不会有相同的哈希值

620
00:34:11,890 --> 00:34:13,200
再次强调，这并非不可能

621
00:34:13,310 --> 00:34:14,350
这是不可行的

622
00:34:14,360 --> 00:34:17,500
如果你看看哈希函数的历史

623
00:34:17,520 --> 00:34:23,410
通常在某个时间点，有些哈希函数不再具有抗碰撞性

624
00:34:23,410 --> 00:34:27,020
比如量子计算出现，或者某些东西会出现

625
00:34:27,260 --> 00:34:31,586
但至少现在，你可以放入任何大小的东西

626
00:34:31,586 --> 00:34:34,180
他们的结果是不同的

627
00:34:36,210 --> 00:34:38,020
它们看起来也非常随机

628
00:34:38,020 --> 00:34:39,930
这就是所谓的雪崩效应

629
00:34:41,220 --> 00:34:44,350
也就是说，如果你改变了一点点

630
00:34:44,360 --> 00:34:45,860
整件事情就都不一样了

631
00:34:45,870 --> 00:34:47,730
如果你在哪个小视频里注意到

632
00:34:47,730 --> 00:34:49,610
如果你改变了一件事

633
00:34:49,630 --> 00:34:51,010
一切看起来都很不同

634
00:34:51,620 --> 00:34:54,400
为什么这很重要，因为它使哈希函数更安全

635
00:34:56,030 --> 00:34:58,340
然后还有一种叫做谜题友好性的东西

636
00:34:58,340 --> 00:35:00,130
即使你了解一点输入

637
00:35:00,130 --> 00:35:02,320
也不意味着你能得到输出

638
00:35:03,270 --> 00:35:06,060
我把这些放在这里不是为了让你去了解他们

639
00:35:06,060 --> 00:35:07,555
你不会接受测试

640
00:35:07,555 --> 00:35:11,130
如果你进入商业，就像阿林那样

641
00:35:11,130 --> 00:35:12,920
你可能开始了，但没有考虑这些

642
00:35:12,920 --> 00:35:16,270
像是，抗碰撞或这个那个

643
00:35:16,300 --> 00:35:21,360
但我想让你知道，这背后有一堆密码学知识

644
00:35:21,710 --> 00:35:22,670
然后

645
00:35:25,106 --> 00:35:26,440
关键是

646
00:35:27,440 --> 00:35:31,400
它不是 100% 不变的

647
00:35:31,460 --> 00:35:40,060
可能是一千万分之一的概率

648
00:35:40,130 --> 00:35:42,400
但依然，这些东西可能会被破坏

649
00:35:42,860 --> 00:35:45,927
被量子计算或其他东西

650
00:35:45,927 --> 00:35:46,720
阿林？

651
00:35:46,720 --> 00:35:50,230
实际概率应该是 1/2 的 28 次方

652
00:35:52,440 --> 00:35:54,370
远远超过 1 千万亿

653
00:35:54,860 --> 00:35:58,920
所以大约是 1/10 的 40 次方

654
00:36:01,900 --> 00:36:05,000
怎么样，我没算错吧？

655
00:36:05,880 --> 00:36:06,530
好的

656
00:36:09,300 --> 00:36:13,000
有兴趣的可以在办公时间来找我

657
00:36:14,710 --> 00:36:17,880
所以它被破解的可能性非常小

658
00:36:18,380 --> 00:36:20,730
但我认为总是值得说

659
00:36:20,730 --> 00:36:22,550
不，存在一些外部因素

660
00:36:22,550 --> 00:36:25,330
它并不像你想象的那样受限

661
00:36:26,000 --> 00:36:27,470
所以

662
00:36:27,470 --> 00:36:29,570
它是用来做什么的，在许多地方

663
00:36:29,570 --> 00:36:32,610
它被用于名称、引用和指针

664
00:36:32,610 --> 00:36:34,709
以及所谓的承诺

665
00:36:35,043 --> 00:36:37,779
在比特币中，它用于指针

666
00:36:37,779 --> 00:36:40,410
因为一个块会指向另一个块

667
00:36:41,310 --> 00:36:44,450
但它也用于承诺

668
00:36:46,120 --> 00:36:47,860
你会听到这些说法

669
00:36:47,870 --> 00:36:49,660
我们不会深入研究它们

670
00:36:49,670 --> 00:36:54,850
但区块头和默克尔树使用了一种叫 SHA-256 的东西

671
00:36:54,850 --> 00:37:02,550
这是一个标准，字面意思是有 256 比特长

672
00:37:02,680 --> 00:37:07,590
这就像 256 个寄存器的 0 和 1

673
00:37:08,810 --> 00:37:10,840
但是实际上，一个比特币地址...

674
00:37:11,420 --> 00:37:14,640
所以中本聪使用了一个循环

675
00:37:15,170 --> 00:37:16,780
我很高兴来说说为什么

676
00:37:16,790 --> 00:37:21,770
他对比特币地址使用了两个哈希函数

677
00:37:21,810 --> 00:37:24,792
我看过... 他实际上写了一篇文章

678
00:37:24,792 --> 00:37:29,310
他说如果其中一个坏了，至少另一个不太可能坏

679
00:37:29,310 --> 00:37:31,460
所以，当我读到这一点的时候

680
00:37:31,460 --> 00:37:33,330
我想他的意思是

681
00:37:33,920 --> 00:37:35,960
你必须对某些东西进行两次哈希

682
00:37:35,970 --> 00:37:38,210
这会让它变得更加安全

683
00:37:38,310 --> 00:37:42,420
尽管阿林提到，这只有 1/10 的 40 次方的概率

684
00:37:42,920 --> 00:37:44,450
这是天文数字般低的

685
00:37:44,820 --> 00:37:46,314
是的，所以

686
00:37:47,830 --> 00:37:48,772
所以还记得

687
00:37:48,772 --> 00:37:49,951
卡罗琳在哪里

688
00:37:49,951 --> 00:37:51,519
我不记得了，在哪里

689
00:37:52,072 --> 00:37:53,121
你问过我关于...

690
00:37:53,121 --> 00:37:54,922
我以为我安排在今天

691
00:37:54,922 --> 00:37:56,824
但幸好你在周二提醒了我

692
00:37:56,824 --> 00:38:02,170
运行时间最长的哈希链，时间戳哈希链是什么？

693
00:38:03,000 --> 00:38:04,690
这是一个很好的问题

694
00:38:06,534 --> 00:38:08,560
感谢你的赞美

695
00:38:10,320 --> 00:38:12,050
答案是

696
00:38:12,060 --> 00:38:13,980
是的，我，我不太

697
00:38:13,980 --> 00:38:15,180
我不记得他的音译

698
00:38:15,180 --> 00:38:17,140
所以我不确定我是否说错了

699
00:38:17,410 --> 00:38:19,030
但它来自贝尔实验室

700
00:38:19,040 --> 00:38:22,817
斯图尔特-海博和"Surety"公司

701
00:38:22,817 --> 00:38:23,710
就这个

702
00:38:24,940 --> 00:38:25,670
没错

703
00:38:25,930 --> 00:38:28,450
所以海博和他的同事

704
00:38:28,540 --> 00:38:30,870
是的，你说对了

705
00:38:31,280 --> 00:38:32,100
那是我室友

706
00:38:32,100 --> 00:38:33,490
这是你室友，棒极了

707
00:38:35,470 --> 00:38:36,430
所以

708
00:38:38,270 --> 00:38:40,910
我只是想说比特币不是第一个

709
00:38:40,920 --> 00:38:43,120
他（海博）在 1991 年就这么做了

710
00:38:43,810 --> 00:38:45,050
但到了 1995 年

711
00:38:45,050 --> 00:38:46,610
他们创办了 “Surety”

712
00:38:46,610 --> 00:38:48,110
我不认为它取得了很大的成功

713
00:38:48,120 --> 00:38:52,340
它没有与苹果去竞争最大的市场，或类似的东西

714
00:38:53,630 --> 00:38:54,460
或着与脸书

715
00:38:55,900 --> 00:38:59,270
但在每周的“通知”栏目

716
00:38:59,270 --> 00:39:04,670
你可以看到一个哈希值，字面意义上的一个

717
00:39:05,060 --> 00:39:08,210
它带有时间戳，因为它在《纽约时报》上

718
00:39:08,970 --> 00:39:11,165
而且它是一个哈希

719
00:39:11,165 --> 00:39:16,280
包含了之前所有信息和其他内容的奇怪的数字

720
00:39:16,320 --> 00:39:19,420
基本上，他们对任何文档进行哈希处理

721
00:39:19,870 --> 00:39:22,760
任何您希望在该周内添加时间戳的文档

722
00:39:22,760 --> 00:39:25,020
你把它列入，一个接着另一个

723
00:39:25,020 --> 00:39:26,500
这就是一条区块链

724
00:39:26,630 --> 00:39:28,240
这不是钱的问题

725
00:39:28,260 --> 00:39:32,260
没有原生货币，等等

726
00:39:33,520 --> 00:39:41,240
我相信，海博和斯图尔特是中本聪论文中八或九个脚注中的三个

727
00:39:41,240 --> 00:39:42,070
也许是四个

728
00:39:42,950 --> 00:39:44,300
所以他得到了称赞

729
00:39:45,250 --> 00:39:47,660
如果你去他的网站 Stuart Haber

730
00:39:47,660 --> 00:39:55,020
我想他在他的个人网站上说自己是区块链的联合创始人

731
00:39:57,320 --> 00:39:58,413
所以现在，我们有...

732
00:39:58,413 --> 00:40:02,190
这是在国家标准技术研究所（NIST）的文件中

733
00:40:02,580 --> 00:40:06,850
但比特币或区块链里，仅附加时间戳的日志中

734
00:40:07,720 --> 00:40:13,220
将一切组合在一起的是头部，即顶部信息

735
00:40:13,820 --> 00:40:16,931
如果我能略过这张图

736
00:40:16,931 --> 00:40:18,960
然后直接提炼重点

737
00:40:19,840 --> 00:40:22,140
有五个关键信息

738
00:40:22,200 --> 00:40:24,350
版本，它不会经常改变

739
00:40:24,350 --> 00:40:26,170
但有一个版本号

740
00:40:27,110 --> 00:40:29,480
前一个区块的哈希值

741
00:40:30,500 --> 00:40:35,550
所以这是关于所有在它之前的块的一些信息

742
00:40:37,210 --> 00:40:39,460
默克尔树根哈希

743
00:40:39,470 --> 00:40:44,900
有人想告诉我这有什么用吗？默克尔根

744
00:40:47,995 --> 00:40:48,670
Brotish？

745
00:40:49,060 --> 00:40:54,502
它实际上将交易发布在树的最底层

746
00:40:54,502 --> 00:40:56,870
然后以此往上构建每个交易的哈希值

747
00:40:57,490 --> 00:40:58,303
所以如果我...

748
00:40:58,303 --> 00:41:01,830
如果我回到这张漂亮的小照片

749
00:41:03,020 --> 00:41:04,310
这个黄色盒子

750
00:41:04,310 --> 00:41:07,060
每个块的底部是所有交易

751
00:41:07,060 --> 00:41:11,310
一个区块中可能有多达 1,000 或 2,000 笔交易

752
00:41:11,330 --> 00:41:14,300
所以有这个区块链概念，1,000  2,000

753
00:41:16,020 --> 00:41:22,030
在中本聪的论文之前，就有手段和方法压缩数据

754
00:41:22,030 --> 00:41:24,900
如何让这些信息更整洁

755
00:41:25,570 --> 00:41:28,340
这使用了一种叫做默克尔根的东西

756
00:41:28,860 --> 00:41:32,130
哪五个位于顶部的东西

757
00:41:32,160 --> 00:41:37,850
所谓的区块头，不包含一千笔交易

758
00:41:38,290 --> 00:41:39,680
早些时候，凯莉

759
00:41:39,680 --> 00:41:44,740
你问过我关于全节点和轻节点的问题

760
00:41:46,100 --> 00:41:53,427
这里任何人都可以在手机上下载轻节点或钱包

761
00:41:53,427 --> 00:42:01,760
但你可能不会下载比特币历史上发生的数百万笔交易

762
00:42:01,780 --> 00:42:05,860
你不太可能下载所谓的全节点

763
00:42:05,960 --> 00:42:08,620
但你可以下载所有区块头

764
00:42:09,010 --> 00:42:11,680
这些就是一个区块头的完整信息

765
00:42:12,750 --> 00:42:15,590
比特币中的所有信息还没有那么大

766
00:42:15,590 --> 00:42:17,470
总量还不到 200G

767
00:42:18,920 --> 00:42:23,391
但所有的区块头，我记得，只有几GB

768
00:42:23,391 --> 00:42:26,360
我现在不记得现在是 4GB 还是 6GB

769
00:42:26,360 --> 00:42:27,787
是多少？

770
00:42:27,787 --> 00:42:30,848
区块头是 80 字节，所以是 80 字节乘以 500,000

771
00:42:30,848 --> 00:42:34,565
即 50MB 到 60 MB 的区块头信息

772
00:42:34,565 --> 00:42:41,250
所以是 60MB，这比 180GB 要小得多

773
00:42:42,680 --> 00:42:46,570
所以中本聪提前考虑到了

774
00:42:46,570 --> 00:42:49,070
以及你将要接触到的每一个区块链

775
00:42:49,160 --> 00:42:51,252
大部分，我是说，可能也有特例

776
00:42:51,252 --> 00:42:58,626
常见的概念是，通过称为标头的一点信息来保持安全性

777
00:42:58,626 --> 00:43:02,660
然后将交易和数据的所有内容向下推

778
00:43:02,800 --> 00:43:05,620
当你遇到像以太坊的区块链时，这一点非常重要

779
00:43:05,620 --> 00:43:11,380
它的每个块中都有大量数据和大量计算

780
00:43:11,400 --> 00:43:13,230
这有点像斯图尔特-海博

781
00:43:16,220 --> 00:43:18,880
他有很多文件和图片，等等

782
00:43:18,880 --> 00:43:23,120
他不会... 你不必拥有所有质量的图片或整部电影

783
00:43:23,130 --> 00:43:25,553
实际上，你可以对整部电影进行哈希处理

784
00:43:25,553 --> 00:43:28,450
然后你会得到这 256 比特

785
00:43:30,958 --> 00:43:31,830
所以...

786
00:43:32,800 --> 00:43:33,270
哎呀

787
00:43:35,220 --> 00:43:37,830
所以标头存有前一个的哈希值

788
00:43:37,840 --> 00:43:41,320
这个默克尔根，只是获取所有交易的一种方式

789
00:43:41,330 --> 00:43:45,973
只要将默克尔根视为以某种打包 2,000 笔交易的方法就行了

790
00:43:46,474 --> 00:43:49,677
时间戳，那个很简单，我们可以越过这个

791
00:43:50,478 --> 00:43:51,980
难度目标

792
00:43:53,860 --> 00:43:55,510
有谁知道区块链...

793
00:43:57,060 --> 00:44:02,857
比特币是怎么做的，随着时间的推移，难度是增加还是减少了？

794
00:44:03,324 --> 00:44:05,593
不，Brotish，我找过你了，雨果

795
00:44:05,593 --> 00:44:11,514
为了维持十分钟出一个块，比特币会调整计算难度

796
00:44:11,514 --> 00:44:15,160
如果系统有更多的计算能力，挖出一个区块就会更难

797
00:44:15,160 --> 00:44:19,240
所以矿工越多，挖出一个区块就越难

798
00:44:20,100 --> 00:44:25,200
所以每个块头都需要有所谓的难度目标

799
00:44:25,200 --> 00:44:29,760
挖矿难度有多大？介于我们会在下周二讨论挖矿

800
00:44:30,110 --> 00:44:33,460
我们会回到难度目标这个概念

801
00:44:34,780 --> 00:44:37,200
接下来，什么是 Nonce?

802
00:44:40,310 --> 00:44:41,040
那是什么?

803
00:44:42,230 --> 00:44:43,564
一个随机数

804
00:44:43,564 --> 00:44:47,120
一个只用一次的随机数，用一次的数，Nonce

805
00:44:50,410 --> 00:44:54,080
那就是... 这就是哈希函数的部分

806
00:44:54,080 --> 00:44:55,100
我们做的怎么样

807
00:44:55,310 --> 00:44:57,860
有点偏离预期，但我们在 MIT

808
00:44:57,860 --> 00:44:58,540
请说

809
00:44:58,540 --> 00:45:03,020
我的问题是，哈希值中的字符串个数等同于...

810
00:45:03,020 --> 00:45:05,540
输出，不是输入

811
00:45:05,540 --> 00:45:07,480
不，我是说，字符串长度

812
00:45:07,520 --> 00:45:09,872
哪个哈希值，它是有限的

813
00:45:09,872 --> 00:45:10,263
对吧

814
00:45:10,263 --> 00:45:10,849
是的

815
00:45:10,849 --> 00:45:12,414
所以你有一个可用的函数池

816
00:45:12,414 --> 00:45:15,470
而你还有很多交易，他们组成一个流

817
00:45:15,496 --> 00:45:16,324
对吧？

818
00:45:16,330 --> 00:45:21,500
所以你会不断的消耗可用的哈希值，然后你会产生重复的哈希值

819
00:45:21,500 --> 00:45:21,800
对吗？

820
00:45:22,570 --> 00:45:23,260
哪你怎么知道

821
00:45:24,130 --> 00:45:24,694
怎么说

822
00:45:24,694 --> 00:45:30,620
当冲突发生时，你如何确定哈希值对应的信息是什么

823
00:45:30,620 --> 00:45:33,090
所以... 你能帮我念一下你的名字吗？

824
00:45:33,090 --> 00:45:38,030
只是... 迪尔莫，他问了正确的问题

825
00:45:38,040 --> 00:45:39,850
他在说，你怎么知道

826
00:45:39,850 --> 00:45:43,740
尤其是当你运行的时间越来越长，越来越长

827
00:45:43,740 --> 00:45:50,080
你可能会从不同的输入得到相同的哈希输出

828
00:45:50,690 --> 00:45:51,930
如果你还记得的话

829
00:45:54,470 --> 00:45:54,880
等一下

830
00:45:55,320 --> 00:45:58,570
确实有人还记得，在 Brotish 前面那位

831
00:45:59,360 --> 00:46:00,110
我想说，是的

832
00:46:00,110 --> 00:46:03,650
论文提到这是可能的，就像...

833
00:46:05,820 --> 00:46:08,170
就像 X 的哈希和 Y 的哈希一致

834
00:46:08,180 --> 00:46:11,420
但如果，矿工们正在工作

835
00:46:11,650 --> 00:46:13,130
比如，不是同时...

836
00:46:13,140 --> 00:46:17,180
比如，如果相同的信息不会在同一时间被处理

837
00:46:17,180 --> 00:46:19,190
这就不会是一个问题，因为然后...

838
00:46:19,560 --> 00:46:22,970
你可以继续，就像两个不同的...

839
00:46:24,010 --> 00:46:27,580
所以，你在和挖矿相关的部分说的没错

840
00:46:27,590 --> 00:46:31,330
但还有另一部分，那就是对于哈希函数而言

841
00:46:31,330 --> 00:46:36,410
如果它是一个好的哈希函数，它就有所谓的抗碰撞性

842
00:46:36,660 --> 00:46:39,100
你所描述的场景非常不可能出现

843
00:46:39,230 --> 00:46:43,060
实际上，概率是 1/10 的 40 次方

844
00:46:43,590 --> 00:46:46,350
你知道，这是一个 1 后面有 40 个 0

845
00:46:46,350 --> 00:46:48,890
它出现的概率极低

846
00:46:50,130 --> 00:46:52,930
这是可能的，但是不可行的

847
00:46:54,370 --> 00:47:01,769
你所谈到的是如果两个矿工同时解决了难题

848
00:47:01,769 --> 00:47:03,130
而不是发生冲突

849
00:47:03,260 --> 00:47:07,350
因为他们同时达到了难度目标

850
00:47:08,060 --> 00:47:08,640
请说

851
00:47:09,100 --> 00:47:10,811
这似乎是一个愚蠢的问题，但是...

852
00:47:10,811 --> 00:47:14,370
不，求知路上没有愚蠢的问题，真的

853
00:47:15,350 --> 00:47:20,400
哪个时间戳属性，是指整个系统的还是其他？

854
00:47:20,400 --> 00:47:25,540
时间戳并不是比特币特别重要的部分

855
00:47:25,550 --> 00:47:26,790
它们带有时间戳

856
00:47:27,990 --> 00:47:30,497
但有时，如果有人将时间戳推迟了

857
00:47:30,497 --> 00:47:33,380
那么就会推迟几分钟甚至长达 2 小时

858
00:47:35,120 --> 00:47:36,310
有一个

859
00:47:36,500 --> 00:47:40,500
技术上，在脚本中有一个检验

860
00:47:40,510 --> 00:47:44,260
时间戳是否超过了几个小时

861
00:47:44,270 --> 00:47:45,170
所以实际上

862
00:47:45,170 --> 00:47:47,650
它没有没那么精确

863
00:47:47,960 --> 00:47:52,453
话虽如此，时间戳出现的真正方式是

864
00:47:52,453 --> 00:47:57,005
如果一个区块被挖掘出来，并且它是第 540,000 个区块

865
00:47:57,005 --> 00:48:00,610
它被所有节点都接受了

866
00:48:00,610 --> 00:48:07,370
这 10,000 个节点开始挖掘 540,001 个

867
00:48:07,420 --> 00:48:08,860
实际上，它是

868
00:48:09,450 --> 00:48:11,430
我认为，它就像一个堆栈

869
00:48:12,000 --> 00:48:13,230
然后...

870
00:48:13,940 --> 00:48:18,040
本质上，比实际时间更重要的是

871
00:48:18,050 --> 00:48:20,650
它们的标头中都会有一个时间戳

872
00:48:22,560 --> 00:48:25,570
但更重要的是块的顺序

873
00:48:26,780 --> 00:48:30,670
最重要的是，前一个块的哈希值

874
00:48:33,620 --> 00:48:34,220
请说

875
00:48:34,420 --> 00:48:35,920
我想说，没有时间戳

876
00:48:35,920 --> 00:48:38,280
你不能进行这个难度调整

877
00:48:38,790 --> 00:48:40,774
时间戳很重要

878
00:48:40,774 --> 00:48:42,369
如果你没有区块中的时间戳

879
00:48:42,369 --> 00:48:45,846
你就无法进行难度调整

880
00:48:45,846 --> 00:48:49,374
这是保持出块时间的 10 分钟所必需的

881
00:48:49,374 --> 00:48:55,107
我部分同意你的观点，因为难度调整每两周进行一次

882
00:48:55,107 --> 00:49:00,840
因此，即使两周内的一个或五六个时间戳有点混乱也无所谓

883
00:49:01,960 --> 00:49:07,995
因为算法查看的是大约 2,000 个区块

884
00:49:08,696 --> 00:49:10,340
是的，所以弄错一点没关系

885
00:49:10,340 --> 00:49:11,390
但你需要时间戳

886
00:49:12,240 --> 00:49:13,500
你需要时间戳

887
00:49:13,510 --> 00:49:17,100
但更重要的是...

888
00:49:17,590 --> 00:49:17,980
是

889
00:49:18,500 --> 00:49:20,060
让我回到第一张幻灯片

890
00:49:20,110 --> 00:49:21,590
是区块的顺序

891
00:49:23,544 --> 00:49:24,260
请说

892
00:49:24,630 --> 00:49:26,820
回到我们刚刚说的碰撞问题

893
00:49:27,720 --> 00:49:30,491
这篇论文并没有详细讨论

894
00:49:30,491 --> 00:49:36,287
但它提到，除了用128次方来描述它有多么不可能之外

895
00:49:36,287 --> 00:49:41,074
即使有两个输入得到了相同的哈希输出

896
00:49:41,074 --> 00:49:45,358
它们也不太可能在上下文中同时有效

897
00:49:45,358 --> 00:49:48,569
因此，在考虑到什么是有效的区块链交易的前提下

898
00:49:48,569 --> 00:49:51,785
这进一步降低了出现问题的可能性

899
00:49:51,785 --> 00:49:57,478
但关于为什么区块链上下文会使两个哈希值相同的可能性

900
00:49:57,478 --> 00:50:02,080
变得更加不太可能，并没有提供太多详细信息

901
00:50:06,070 --> 00:50:08,100
我想把这个问题留到周二

902
00:50:08,100 --> 00:50:11,770
但这与碰撞问题无关

903
00:50:11,770 --> 00:50:16,780
论文谈论的是如果两个矿工同时解决了问题

904
00:50:17,390 --> 00:50:20,701
这并不意味着他们得到了相同的哈希值

905
00:50:20,701 --> 00:50:27,370
因为这个谜题的目标不是获得精确的哈希值

906
00:50:27,830 --> 00:50:32,950
比特币的难题在于，需要有一定数量的前导零

907
00:50:32,960 --> 00:50:37,490
从字面上看就是，它以 9 或 10 个零作为开始

908
00:50:37,540 --> 00:50:39,160
但这说的是在 10 年前

909
00:50:39,250 --> 00:50:41,390
现在你必须哈希一些东西

910
00:50:41,410 --> 00:50:45,092
然后得到，我认为大约是 20 或 26 个前导零

911
00:50:45,092 --> 00:50:47,530
这意味着它变得越来越困难

912
00:50:47,930 --> 00:50:51,750
哈希的结果必须有一堆前导零

913
00:50:51,750 --> 00:50:53,380
你在那个视频中看到了

914
00:50:53,380 --> 00:50:53,920
请说

915
00:50:54,250 --> 00:50:58,530
我有一个问题，哈希是怎么... 默克尔树中的哈希是怎么出现的

916
00:50:58,530 --> 00:51:02,130
所以如果只是对交易进行哈希处理

917
00:51:02,140 --> 00:51:06,480
当上一个区块的哈希发生变化时它会如何变化

918
00:51:07,600 --> 00:51:08,210
好的

919
00:51:08,210 --> 00:51:09,316
艾迪

920
00:51:09,316 --> 00:51:14,100
艾迪让我想起约翰尼·卡森的老电视节目

921
00:51:14,100 --> 00:51:16,340
你刚刚为这位喜剧演员做了一个很好的准备

922
00:51:16,340 --> 00:51:17,540
所以，谢谢你

923
00:51:18,910 --> 00:51:20,730
所以现在我要来谈论默克尔根

924
00:51:21,650 --> 00:51:25,580
所以默克尔根是一种二进制数据树

925
00:51:25,640 --> 00:51:27,080
看起来像这样

926
00:51:28,090 --> 00:51:31,320
如果一个人有 1,000 笔交易

927
00:51:31,840 --> 00:51:33,520
我不会做很漂亮的幻灯片

928
00:51:33,530 --> 00:51:36,190
所以这只描述了四个级别

929
00:51:36,200 --> 00:51:38,830
但考虑底部的四笔交易

930
00:51:40,190 --> 00:51:41,560
它们都经过一次哈希

931
00:51:42,660 --> 00:51:45,260
然后你就可以进行连接

932
00:51:45,260 --> 00:51:46,850
你把两个哈希值放在一起

933
00:51:46,850 --> 00:51:49,520
你将他们再做一次哈希，往上构建出树

934
00:51:49,530 --> 00:51:53,000
如果您有 1,000 笔交易

935
00:51:53,750 --> 00:51:56,660
因为这差不多是 2 的 10 次方

936
00:51:56,660 --> 00:51:59,570
那么这个树就有 10 层

937
00:52:00,520 --> 00:52:02,560
这就是会发生的事情

938
00:52:02,560 --> 00:52:08,971
而且实际上，挖矿操作员帮助节点大量执行这项任务

939
00:52:08,971 --> 00:52:14,280
但在比特币及其核心应用中

940
00:52:14,290 --> 00:52:18,030
在一个这个房间里的任何人都可以下载的软件中

941
00:52:18,030 --> 00:52:18,760
只要你想

942
00:52:18,780 --> 00:52:22,110
有软件可以帮助处理交易

943
00:52:22,900 --> 00:52:27,060
将它们放入这个被称为默克尔树的二叉树中

944
00:52:27,060 --> 00:52:32,499
使用哈希函数然后从底部一路构建到顶部，这是不是...

945
00:52:32,499 --> 00:52:37,630
我认为我的问题是，如果这个结构

946
00:52:37,839 --> 00:52:39,720
假设该结构已经存在

947
00:52:39,720 --> 00:52:43,877
根哈希会因为上一个块的哈希而有什么变化

948
00:52:43,877 --> 00:52:47,659
我们看到，如果你更改前一个块的哈希值

949
00:52:47,659 --> 00:52:51,420
所有指向它的区块都会失效，因为哈希值改变了

950
00:52:51,420 --> 00:52:52,019
所以...

951
00:52:52,019 --> 00:52:53,990
但它似乎没有用前一个的哈希值

952
00:52:53,990 --> 00:52:55,989
所以... 我先重复这个问题

953
00:52:55,989 --> 00:53:03,940
默克尔根是一个区块中 10,000 笔交易的摘要

954
00:53:04,000 --> 00:53:10,310
它是否因为区块头中的其他属性，变化而变化

955
00:53:10,330 --> 00:53:12,310
答案是不会

956
00:53:13,770 --> 00:53:18,380
它只会在 10,000 笔交易中的某些数据发生变化时变化

957
00:53:20,310 --> 00:53:23,850
因此，如果你将不同的交易混合在一起

958
00:53:23,850 --> 00:53:27,187
默克尔根将会改变

959
00:53:27,187 --> 00:53:29,770
或者... 这一点非常重要

960
00:53:29,770 --> 00:53:35,162
作为激励措施之一， 你会通过一笔铸币交易

961
00:53:35,162 --> 00:53:38,150
在今天，获得 12.5 个比特币

962
00:53:38,170 --> 00:53:41,650
所以这 1,000 笔交易中有 1 笔是相同的

963
00:53:42,290 --> 00:53:44,160
支付给矿工的那笔

964
00:53:44,950 --> 00:53:49,140
所以默克尔根会根据谁赢得记账权而有所不同

965
00:53:51,090 --> 00:53:52,820
但这不是你想问的

966
00:53:52,950 --> 00:53:53,660
我只是说...

967
00:53:53,670 --> 00:53:59,870
但默克尔根是处理数千笔交易的非常有效的方式

968
00:53:59,980 --> 00:54:01,990
储存起来，存放在一个地方

969
00:54:04,170 --> 00:54:04,800
请说

970
00:54:05,130 --> 00:54:10,530
因此，对于每个进行哈希处理的人来说

971
00:54:10,530 --> 00:54:12,890
不同交易的顺序必须完全相同，是吗？

972
00:54:12,890 --> 00:54:14,600
不，其实不是

973
00:54:14,640 --> 00:54:17,771
因此，如果你在进行哈希运算，他在运行采矿设备

974
00:54:17,771 --> 00:54:20,430
而阿林也在运行采矿设备

975
00:54:20,800 --> 00:54:27,547
如果阿林解决了这个难题并将结果在网络上传播

976
00:54:27,547 --> 00:54:30,317
人们开始在阿林的区块后面采矿

977
00:54:30,317 --> 00:54:32,110
因为他们说，嘿，他解决了

978
00:54:32,110 --> 00:54:33,340
你没有

979
00:54:33,670 --> 00:54:37,090
你可能会开始在这个块的后面进行挖掘

980
00:54:37,090 --> 00:54:39,080
并查看称为内存池的东西

981
00:54:39,080 --> 00:54:44,040
内存池是一个包含所有未上链交易的网络

982
00:54:44,040 --> 00:54:46,440
你将获得下一组交易

983
00:54:46,860 --> 00:54:52,300
那么我们如何才能验证矿工选择的所有交易

984
00:54:52,620 --> 00:54:53,990
是合法的

985
00:54:54,550 --> 00:54:55,230
好的

986
00:54:55,280 --> 00:54:56,400
所以验证问题

987
00:54:56,400 --> 00:54:58,230
这是下周四要讨论的

988
00:54:58,240 --> 00:54:59,470
但我现在会尝试一下

989
00:54:59,810 --> 00:55:01,390
没事，这是个好问题

990
00:55:01,850 --> 00:55:04,117
每一笔交易...

991
00:55:04,751 --> 00:55:06,453
还是，你其实在给我设陷阱

992
00:55:06,453 --> 00:55:08,340
数字签名，就这样吧

993
00:55:08,350 --> 00:55:09,000
谢谢你

994
00:55:09,040 --> 00:55:09,800
你有问题吗？

995
00:55:09,810 --> 00:55:11,158
或者我会继续

996
00:55:11,158 --> 00:55:13,710
第二个加密操作

997
00:55:13,760 --> 00:55:15,540
我们将继续来回讨论

998
00:55:15,650 --> 00:55:18,900
哈希函数本质上是一种压缩很多数据的方法

999
00:55:19,410 --> 00:55:23,950
生成指纹，并确保其基本上是承诺的方法

1000
00:55:25,300 --> 00:55:28,220
数字签名，嗯，还记得我们之前提到的那个小图吗？

1001
00:55:28,220 --> 00:55:29,590
爱丽丝和鲍勃

1002
00:55:30,190 --> 00:55:34,080
爱丽丝想给鲍勃发一张便条，说：“鲍勃，你好”

1003
00:55:34,690 --> 00:55:36,040
她想加密这条信息

1004
00:55:36,840 --> 00:55:39,320
她用鲍勃公钥对其进行加密

1005
00:55:40,280 --> 00:55:41,204
发给他

1006
00:55:41,204 --> 00:55:43,516
鲍勃用他的私钥解密

1007
00:55:43,516 --> 00:55:45,135
你可能会说，我的天啊

1008
00:55:45,135 --> 00:55:47,661
甘斯勒，什么是私钥，什么是公钥

1009
00:55:48,061 --> 00:55:51,698
在密码学中，这是一种打乱信息的方式

1010
00:55:51,698 --> 00:55:54,067
我知道，我真的在把这件事弄得像...

1011
00:55:54,067 --> 00:55:55,135
但它...

1012
00:55:55,135 --> 00:55:59,310
但如果我们回到那个小机制

1013
00:55:59,930 --> 00:56:04,770
罗马人曾用的，或者德国使用的恩尼格玛密码机

1014
00:56:05,560 --> 00:56:08,080
它们是对称密码学

1015
00:56:09,450 --> 00:56:11,400
两方都有钥匙

1016
00:56:11,400 --> 00:56:15,322
密钥是恩尼格玛机上的五个转子

1017
00:56:16,289 --> 00:56:18,250
在 20 世纪 70 年代末

1018
00:56:18,270 --> 00:56:22,940
其他地方的一些出色的技术专家说

1019
00:56:22,940 --> 00:56:24,965
如果密钥不相同会怎么样？

1020
00:56:25,499 --> 00:56:28,450
因为对手可能会窃取密钥

1021
00:56:29,010 --> 00:56:31,570
如果它不是对称的而是非对称的呢？

1022
00:56:31,580 --> 00:56:33,330
有一个私钥和一个公钥

1023
00:56:33,750 --> 00:56:38,745
本质上，这两个密钥之间存在某种数学关系

1024
00:56:39,179 --> 00:56:43,740
这两个密码之间的数学对于我们这门课并不重要

1025
00:56:43,740 --> 00:56:48,580
但要知道公钥和私钥链接在一起

1026
00:56:50,010 --> 00:56:51,810
他们是绑定在一起的

1027
00:56:52,870 --> 00:56:58,910
但关键是数字签名，它有三个功能

1028
00:56:58,920 --> 00:57:00,550
你必须生成密钥对

1029
00:57:00,550 --> 00:57:02,610
当生成密钥对时

1030
00:57:02,630 --> 00:57:07,170
公钥和私钥同时生成

1031
00:57:08,200 --> 00:57:11,130
他们需要一个随机数来进行创建

1032
00:57:11,570 --> 00:57:16,480
导致很多比特币和其他钱包不安全的原因之一

1033
00:57:18,220 --> 00:57:20,520
这可能就是有些人被黑客攻击的原因

1034
00:57:21,030 --> 00:57:22,889
钱包，不是比特币

1035
00:57:22,889 --> 00:57:25,820
是因为它们没有良好的随机数生成功能

1036
00:57:25,850 --> 00:57:26,940
Brotish，请说

1037
00:57:28,840 --> 00:57:31,832
我看到... 上周我参加了一个会议

1038
00:57:32,532 --> 00:57:36,837
宾夕法尼亚大学的一位技术专家进行了调查

1039
00:57:36,837 --> 00:57:43,490
针对对 150 家对冲基金、挖矿公司和比特币钱包公司等

1040
00:57:43,500 --> 00:57:48,281
所以他们实际上让一名网络安全人员进入

1041
00:57:48,281 --> 00:57:54,521
并对 150 位真正投入的，高端比特币用户进行调查

1042
00:57:54,521 --> 00:57:59,830
包括矿工、对冲基金和加密交易所

1043
00:58:00,460 --> 00:58:01,860
结果太可怕了

1044
00:58:01,970 --> 00:58:07,133
他们的网络安全措施在处理私钥时存在严重问题

1045
00:58:07,133 --> 00:58:09,236
甚至在他创建私钥之前

1046
00:58:09,236 --> 00:58:15,120
许多人实际上并没有安全的方式来生成用于创建私钥的随机数

1047
00:58:15,675 --> 00:58:17,944
所以，这只是一个插曲

1048
00:58:17,944 --> 00:58:21,978
当有人说他们有非常好的私钥和公钥时

1049
00:58:21,978 --> 00:58:27,203
在后面，你应该想到，不对，必须有某种方法来生成随机数

1050
00:58:27,203 --> 00:58:31,682
这是我要你记住的唯一数学

1051
00:58:33,540 --> 00:58:35,120
签名功能

1052
00:58:35,120 --> 00:58:37,940
关键是签名的生成

1053
00:58:37,950 --> 00:58:42,910
你可以从一条消息和一个私钥创建数字签名

1054
00:58:45,110 --> 00:58:47,908
因此，如果凯莉有一个私钥

1055
00:58:47,908 --> 00:58:52,970
并且想要向房间另一边的某人发送秘密消息

1056
00:58:52,970 --> 00:58:54,920
伊莎贝拉，你想要凯莉的消息吗？

1057
00:58:57,400 --> 00:58:59,150
凯莉会拿着这个消息

1058
00:59:00,210 --> 00:59:01,200
你懂了吗？凯莉

1059
00:59:01,850 --> 00:59:05,670
你将拿着消息，并用私钥对其进行签名

1060
00:59:07,130 --> 00:59:08,700
你把它发给伊莎贝拉

1061
00:59:10,940 --> 00:59:13,280
伊丽莎白怎么知道这条消息是你发的？

1062
00:59:14,550 --> 00:59:16,980
她要用她的密钥解密

1063
00:59:19,210 --> 00:59:20,640
她得去核实一下

1064
00:59:20,700 --> 00:59:23,590
所以就有了一个函数叫验证函数

1065
00:59:23,630 --> 00:59:25,600
它会返回是或不是

1066
00:59:26,130 --> 00:59:28,300
我是说，它可能会以不同的方式表达

1067
00:59:28,300 --> 00:59:29,610
但基本上是，是或否

1068
00:59:29,930 --> 00:59:31,610
这是一个验证函数

1069
00:59:31,630 --> 00:59:32,710
伊莎贝拉

1070
00:59:32,790 --> 00:59:34,154
你想和我一起过一遍吗？

1071
00:59:34,154 --> 00:59:39,570
将验证你的签名对于这条消息是否有效

1072
00:59:39,580 --> 00:59:41,950
因为她有公钥

1073
00:59:42,620 --> 00:59:43,610
所以你是对的

1074
00:59:43,620 --> 00:59:45,050
伊莎贝拉有你的公钥

1075
00:59:46,750 --> 00:59:49,100
但使用你的公钥

1076
00:59:49,230 --> 00:59:51,290
她可以验证签名

1077
00:59:51,930 --> 00:59:53,260
这是神奇的数学

1078
00:59:53,990 --> 00:59:55,350
不，这不是神奇的数学

1079
00:59:55,370 --> 00:59:56,480
这是真实的数学

1080
00:59:57,020 --> 01:00:00,740
但这不是我们要在这门课里学习的数学

1081
01:00:00,740 --> 01:00:01,312
请说，雨果

1082
01:00:01,598 --> 01:00:03,887
回到生成密钥对那里

1083
01:00:03,887 --> 01:00:04,460
好的

1084
01:00:04,750 --> 01:00:08,688
所以它们都是从随机数生成的？还是像...

1085
01:00:08,688 --> 01:00:12,850
像是私钥由公钥决定，或者反过来

1086
01:00:13,520 --> 01:00:16,020
公钥... 你可以试想

1087
01:00:16,260 --> 01:00:21,320
在比特币中，它使用椭圆曲线加密技术

1088
01:00:21,430 --> 01:00:28,410
你可以认为，私钥是基于随机数的

1089
01:00:29,310 --> 01:00:32,345
说的更专业一点，其实是...

1090
01:00:35,048 --> 01:00:38,160
随机数可以让你获得公钥

1091
01:00:38,160 --> 01:00:41,560
但我认为，私钥基本上就是你的随机数

1092
01:00:41,580 --> 01:00:43,670
然后公钥会用它来生成

1093
01:00:44,320 --> 01:00:44,690
所以...

1094
01:00:46,870 --> 01:00:47,600
是的

1095
01:00:49,300 --> 01:00:54,067
所以你在 0 到 2 的 256 次方 之间选择一个二进制随机数

1096
01:00:54,067 --> 01:00:55,030
这就是你的私钥

1097
01:00:55,030 --> 01:00:58,340
为了获得公钥，你直接从私钥导出它

1098
01:00:58,340 --> 01:01:02,360
实际上，你所要做的就是用你的私钥对另一个数字求幂

1099
01:01:03,490 --> 01:01:08,290
所以，你可以将公钥视为私钥的单向函数

1100
01:01:08,340 --> 01:01:11,100
因此，给定一个公钥，你无法获得私钥

1101
01:01:11,100 --> 01:01:14,080
如果你可以的话，那么你就可以做签名了，这是灾难性的

1102
01:01:16,250 --> 01:01:22,350
在比特币中，他用的是椭圆曲线加密函数，不是指数

1103
01:01:22,350 --> 01:01:24,080
不过... 那么它有哪些特性呢？

1104
01:01:24,080 --> 01:01:28,070
这些是关键的经济属性以及加密属性

1105
01:01:28,330 --> 01:01:30,090
基本上，这是不可行的

1106
01:01:30,090 --> 01:01:31,930
再一次，我用了“不可行”这个词

1107
01:01:31,940 --> 01:01:33,800
我没说不可能

1108
01:01:34,100 --> 01:01:39,000
即使阿林可能想告诉我，这是 1/10 的 40 次方之类的

1109
01:01:39,100 --> 01:01:44,350
但是，通过公钥找到私钥这样的逆向工程是不可行的

1110
01:01:44,770 --> 01:01:47,650
所以即使你没有私钥

1111
01:01:48,300 --> 01:01:53,980
就像在凯莉和伊莎贝拉的例子中，我知道凯莉的公钥

1112
01:01:54,740 --> 01:01:59,420
我可以冒充凯莉给伊莎贝拉发消息吗？

1113
01:01:59,420 --> 01:02:00,366
不能

1114
01:02:01,400 --> 01:02:04,320
你需要做一个签名

1115
01:02:05,521 --> 01:02:08,074
如果你注意一下这里

1116
01:02:08,074 --> 01:02:12,210
你需要一个私钥和一条消息来进行数字签名

1117
01:02:12,210 --> 01:02:15,949
它是关于私钥和信息的函数

1118
01:02:19,810 --> 01:02:21,400
我们称之为复杂数学

1119
01:02:22,490 --> 01:02:29,440
该数字签名是根据私钥创建的

1120
01:02:30,060 --> 01:02:33,810
公钥是根据私钥创建的

1121
01:02:34,150 --> 01:02:38,538
简化一下，验证功能起作用的原因

1122
01:02:38,538 --> 01:02:44,590
是因为数字签名和伊莎贝拉拥有的公钥

1123
01:02:44,600 --> 01:02:47,030
伊莎贝拉有这个数字签名

1124
01:02:47,640 --> 01:02:52,330
她有公钥，还有消息

1125
01:02:54,060 --> 01:03:01,170
基本上，私钥的数学运算就像因式分解一样

1126
01:03:01,660 --> 01:03:02,680
你知道，你...

1127
01:03:02,790 --> 01:03:04,860
但想一想这两个功能

1128
01:03:04,870 --> 01:03:10,380
伊莎贝拉得到了凯莉的公钥、消息和数字签名

1129
01:03:10,390 --> 01:03:12,090
她要么验证，要么不验证

1130
01:03:12,100 --> 01:03:14,470
但她永远不必看到私钥

1131
01:03:14,580 --> 01:03:17,700
而事实上，凯莉不希望她看到私钥

1132
01:03:18,260 --> 01:03:18,876
埃里克

1133
01:03:19,712 --> 01:03:27,554
我想尝试简化一下数字签名得以运行并实现验证的原理

1134
01:03:27,554 --> 01:03:33,960
就是将凯莉的信息经过一次哈希运算，生成一个哈希值

1135
01:03:33,960 --> 01:03:37,080
然后用她的私钥加密

1136
01:03:37,480 --> 01:03:42,961
然后加密的消息和数字签名被发送给伊莎贝拉

1137
01:03:42,961 --> 01:03:48,474
伊莎贝拉所做的是使用相同的哈希函数对文档进行运算

1138
01:03:48,474 --> 01:03:54,280
生成哈希值，并使用凯莉的公钥来解密签名

1139
01:03:54,280 --> 01:03:56,015
并比对这两个数值

1140
01:03:56,015 --> 01:04:02,740
如果相同，这意味着该消息属于凯莉并且未被篡改

1141
01:04:02,750 --> 01:04:09,690
这差不多是数字签名的简化

1142
01:04:09,690 --> 01:04:11,652
我不知道是否...

1143
01:04:11,652 --> 01:04:14,300
我是说，关键在于

1144
01:04:14,300 --> 01:04:20,106
由于许多原因，互联网上存在一个与比特币无关的方案

1145
01:04:20,150 --> 01:04:24,210
很多的原因，包括在商业和战争中

1146
01:04:25,640 --> 01:04:29,400
使得这个公钥、私钥密码学...

1147
01:04:29,950 --> 01:04:33,210
这不仅仅是... 回到前面

1148
01:04:33,210 --> 01:04:35,800
这不仅仅是爱丽丝发送一些东西

1149
01:04:35,810 --> 01:04:37,760
这也关乎数字签名

1150
01:04:38,240 --> 01:04:40,070
你生成密钥对

1151
01:04:40,100 --> 01:04:44,030
比特币、以太坊中的一切，都有密钥对

1152
01:04:44,030 --> 01:04:47,070
公钥和私钥、数字签名

1153
01:04:47,400 --> 01:04:50,280
但凯莉，永远不要丢掉你的私钥

1154
01:04:51,380 --> 01:04:52,620
明白吗？永远不要

1155
01:04:53,070 --> 01:04:56,640
顺便，你必须用一个好的随机数生成器来创建它

1156
01:04:56,640 --> 01:05:00,220
因为世界上最复杂的对冲基金都没有这么做

1157
01:05:00,230 --> 01:05:01,810
所以你会比那些人更好

1158
01:05:01,810 --> 01:05:04,270
这是我在最近参加的一次会议上了解到的

1159
01:05:04,770 --> 01:05:06,750
然后还有一个验证功能

1160
01:05:07,750 --> 01:05:12,450
关于随机数生成器和验证功能的一个简单问题

1161
01:05:12,540 --> 01:05:18,231
是否有第三方生成器生成这个随机数生成器

1162
01:05:18,231 --> 01:05:24,570
或者这个生成器是一个已经存在的函数

1163
01:05:24,570 --> 01:05:25,040
有很多

1164
01:05:26,330 --> 01:05:28,708
所以，这个问题是

1165
01:05:28,708 --> 01:05:31,615
既然随机数生成如此重要

1166
01:05:31,615 --> 01:05:37,383
是否有优秀的外部软件来生成随机数

1167
01:05:37,383 --> 01:05:40,219
答案是肯定的，但还有一些不太好的

1168
01:05:40,219 --> 01:05:42,789
而且是的，一些好的笔记本电脑就有这个功能

1169
01:05:42,789 --> 01:05:46,970
实际上，我想要提前介绍一下

1170
01:05:47,390 --> 01:05:49,820
椭圆曲线数字签名算法

1171
01:05:49,930 --> 01:05:56,480
这是比特币实际使用的算法，用于处理私钥等等

1172
01:05:56,750 --> 01:05:58,980
但很多的... 数字钱包

1173
01:05:59,210 --> 01:06:06,312
如果你下载一个数字钱包来保存你的比特币、莱特币

1174
01:06:06,312 --> 01:06:07,620
或其他数字货币

1175
01:06:07,630 --> 01:06:15,590
那个钱包应用会有一个随机数生成软件

1176
01:06:15,610 --> 01:06:19,130
我不能验证所有的随机数生成软件

1177
01:06:19,150 --> 01:06:22,200
我不是网络安全人士或专家

1178
01:06:22,290 --> 01:06:29,670
但可能存在一些更强大的随机数生成软件

1179
01:06:29,670 --> 01:06:39,912
随机数生成的关键是，生成的任何长度都确保没有聚集

1180
01:06:39,912 --> 01:06:43,750
合理的表述是，保证具有最大熵

1181
01:06:44,010 --> 01:06:44,380
你知道

1182
01:06:44,380 --> 01:06:46,452
确保没有很多的聚集

1183
01:06:47,520 --> 01:06:52,100
如果所有东西都聚集在一个区域，那么这不是很大的随机性

1184
01:06:52,100 --> 01:06:53,593
我想尽快结束

1185
01:06:53,593 --> 01:06:59,000
因为我们要讨论另一件事来奠定基础，那就是比特币地址

1186
01:06:59,000 --> 01:06:59,930
我先放上来

1187
01:06:59,940 --> 01:07:01,950
你可以稍后查看幻灯片

1188
01:07:01,980 --> 01:07:04,180
细节并不重要

1189
01:07:05,000 --> 01:07:11,440
但关键是，当你听到有人谈论公钥和比特币地址时

1190
01:07:11,450 --> 01:07:14,890
通常，我们将两者视为一种东西

1191
01:07:15,080 --> 01:07:16,616
但它们实际上不是

1192
01:07:17,817 --> 01:07:21,521
中本聪采用的技术是

1193
01:07:22,188 --> 01:07:24,080
他使用公钥

1194
01:07:24,940 --> 01:07:30,150
他用这个程序对它进行了两次哈希处理

1195
01:07:30,150 --> 01:07:32,700
一次用被称为 SHA-256 的哈希函数

1196
01:07:32,730 --> 01:07:34,700
然后用另一个哈希函数再做一次

1197
01:07:34,700 --> 01:07:39,372
将他们连接起来，并在末尾放置校验和

1198
01:07:39,372 --> 01:07:43,710
然后使用称为 BASE-58 的东西使其更短

1199
01:07:45,160 --> 01:07:51,984
我回顾了一些中本聪在发布比特币后两年内的一些电子邮件

1200
01:07:51,984 --> 01:07:53,090
以及一些其他资料

1201
01:07:53,090 --> 01:07:56,756
我的理解是，有两个哈希函数的原因

1202
01:07:56,756 --> 01:08:01,230
实际上是两个不一样的，这只是为了让一切变得更安全

1203
01:08:02,310 --> 01:08:04,420
而且，公钥很长

1204
01:08:04,420 --> 01:08:06,330
大约是 512 比特

1205
01:08:07,750 --> 01:08:15,341
因此，你可以缩小数据并通过哈希来使数据压缩程度更高

1206
01:08:15,341 --> 01:08:17,490
这使它达到 256 比特

1207
01:08:17,490 --> 01:08:18,900
他进行了两次哈希

1208
01:08:19,080 --> 01:08:23,360
然后他使用 BASE-58，这使得它变得更短

1209
01:08:24,530 --> 01:08:26,930
所以无论出于何种目的

1210
01:08:26,930 --> 01:08:30,930
你可以继续将公钥和比特币地址视为相同的概念

1211
01:08:30,930 --> 01:08:33,090
但在脑海中，你要记住

1212
01:08:33,090 --> 01:08:33,780
哦，实际上

1213
01:08:33,780 --> 01:08:35,570
它们有一点不同

1214
01:08:35,980 --> 01:08:40,850
按理来讲，比特币地址更安全一点

1215
01:08:40,900 --> 01:08:45,790
当然，除非有人侵入了你的钱包并弄清了所有这些小细节

1216
01:08:46,850 --> 01:08:53,446
比特币地址有点像我们谈到的这些支票上的签名

1217
01:08:54,510 --> 01:08:54,900
对吧？

1218
01:08:54,910 --> 01:08:58,970
记住，有一半的人不使用支票账户

1219
01:08:58,970 --> 01:09:01,780
但这些是支票的早期形式

1220
01:09:02,320 --> 01:09:08,750
在底部有一个签名，那实际上就是比特币地址

1221
01:09:08,750 --> 01:09:11,220
抱歉，签名是数字签名

1222
01:09:11,830 --> 01:09:15,360
而比特币地址则是指支付对象

1223
01:09:15,370 --> 01:09:17,750
我保证这是最后一张幻灯片

1224
01:09:17,760 --> 01:09:20,890
我们下周会讨论这个，交易

1225
01:09:20,900 --> 01:09:23,880
所有那些卷进默克尔树的东西

1226
01:09:23,890 --> 01:09:27,250
所有这些微小但重要的信息

1227
01:09:27,860 --> 01:09:31,050
基本上，他们有一个输入和一个输出

1228
01:09:32,100 --> 01:09:34,220
输入和一个锁定时间

1229
01:09:34,730 --> 01:09:38,700
但输入是一个此前的交易

1230
01:09:39,020 --> 01:09:43,030
基本上，这唯一的标识了货币

1231
01:09:44,530 --> 01:09:47,430
你将发送以“聪”为单位的价值

1232
01:09:49,480 --> 01:09:53,140
他以自己命名了记账单位

1233
01:09:54,380 --> 01:09:56,840
每个比特币中包含很多聪

1234
01:09:56,840 --> 01:09:58,950
这就是为什么我们很少听说聪

1235
01:09:58,950 --> 01:10:03,140
但每个比特币中有 10 的 8 次方个聪

1236
01:10:04,310 --> 01:10:08,650
因此，当你在交易中输入操作代码时

1237
01:10:08,650 --> 01:10:10,310
你所使用的单位是聪

1238
01:10:11,720 --> 01:10:15,000
然后它被发送到一个公钥，那就是一枚硬币

1239
01:10:15,140 --> 01:10:18,670
这就是激励系统的意义所在

1240
01:10:21,390 --> 01:10:22,930
还有其他问题吗？

1241
01:10:24,510 --> 01:10:26,940
这就是... 我知道内容很多

1242
01:10:27,530 --> 01:10:30,040
我想知道你们中有多少人周四会回来

1243
01:10:31,440 --> 01:10:31,790
不

1244
01:10:31,800 --> 01:10:33,020
让我这么说

1245
01:10:33,030 --> 01:10:34,780
这不仅仅是因为我们在 MIT

1246
01:10:34,800 --> 01:10:35,940
但我们确实在 MIT

1247
01:10:35,950 --> 01:10:42,760
拜托，这个房间里的每个人都可以理解这些关键概念

1248
01:10:43,130 --> 01:10:48,420
我们讨论的关键问题是带时间戳的仅添加式日志

1249
01:10:48,420 --> 01:10:49,890
有谁想告诉我什么是...

1250
01:10:49,890 --> 01:10:54,860
如果我们在接下来的 7 分钟能掌握这 2 个概念

1251
01:10:54,860 --> 01:10:57,390
这就是我们在过去 1 个小时所谈论的一切

1252
01:10:57,390 --> 01:10:58,060
所以...

1253
01:10:58,310 --> 01:11:00,300
我不知道穿橙色衬衫这位的名字

1254
01:11:02,020 --> 01:11:03,700
那是什么，安德鲁？

1255
01:11:03,700 --> 01:11:04,190
安德鲁

1256
01:11:04,190 --> 01:11:06,570
什么是带时间戳的仅追加式日志

1257
01:11:06,600 --> 01:11:12,610
带时间戳的仅追加式日志是区块链使用的交易或区块的记录

1258
01:11:13,000 --> 01:11:15,460
有时间戳，所以这在未来是无法改变的

1259
01:11:15,590 --> 01:11:17,060
所以你只能添加交易

1260
01:11:17,060 --> 01:11:20,320
所以，因为这些密码学，它是不可变的

1261
01:11:20,960 --> 01:11:26,260
斯图尔特·海博在制作带时间戳的仅追加式日志

1262
01:11:26,260 --> 01:11:27,867
他把它放在哪里？

1263
01:11:27,867 --> 01:11:30,636
卡洛琳，你还在吗？ 海博把它放在哪里了？

1264
01:11:31,360 --> 01:11:33,820
纽约时报 -- 纽约时报，是这样的

1265
01:11:33,920 --> 01:11:35,300
在分类部分

1266
01:11:37,600 --> 01:11:42,890
所以它只是一堆压缩的数据块

1267
01:11:42,890 --> 01:11:46,652
所以我们讨论了叫做默克尔树和默克尔根的东西

1268
01:11:46,652 --> 01:11:50,670
将他们看作一种获取大量信息并对其进行压缩的方法

1269
01:11:50,670 --> 01:11:55,661
但也让它便于稍后搜索，当有 1,000 笔交易...

1270
01:11:55,661 --> 01:11:56,930
我们会在下周讨论

1271
01:11:56,940 --> 01:11:58,740
你必须能够验证...

1272
01:11:58,740 --> 01:12:00,920
有人问过我如何验证，对吧？

1273
01:12:01,520 --> 01:12:03,030
当你回去验证时

1274
01:12:03,030 --> 01:12:07,306
您需要一个索引号才能在哪个默克尔树中找到它

1275
01:12:08,570 --> 01:12:10,480
并且它通过哈希函数来保护

1276
01:12:10,480 --> 01:12:14,350
有人想告诉我哈希函数最简单的定义吗？

1277
01:12:16,740 --> 01:12:17,620
詹妮弗

1278
01:12:18,680 --> 01:12:25,780
它就像一个映射，使得输入只会去向一个地方

1279
01:12:26,192 --> 01:12:26,560
是的

1280
01:12:27,240 --> 01:12:31,810
你可以给这间教室和其中的每个人拍一张照片

1281
01:12:33,199 --> 01:12:35,620
他们可以映射成某种东西

1282
01:12:35,760 --> 01:12:38,810
我不知道二维码是不是哈希的一种形式

1283
01:12:41,006 --> 01:12:43,220
它没有加密，不够安全

1284
01:12:43,220 --> 01:12:45,044
但它算不算哈希函数？

1285
01:12:45,044 --> 01:12:49,449
它更像是数据不同的表示方法，而不是你所用的二进制

1286
01:12:49,449 --> 01:12:51,302
好吧，我想错了

1287
01:12:51,302 --> 01:12:52,120
它不是

1288
01:12:53,140 --> 01:12:54,970
它经常存储哈希值

1289
01:12:55,800 --> 01:13:00,126
因此，加密哈希函数不仅是一种获取大量信息

1290
01:13:00,126 --> 01:13:02,290
并将其转化为固定形式的方法

1291
01:13:02,320 --> 01:13:06,890
但这里的关键是，哈希函数将区块连接在一起

1292
01:13:06,910 --> 01:13:10,610
因为哈希函数可以指向之前的信息

1293
01:13:10,830 --> 01:13:12,830
正如视频所示

1294
01:13:12,830 --> 01:13:16,260
如果您更改任何基础信息

1295
01:13:16,320 --> 01:13:17,890
哈希值就会改变

1296
01:13:17,890 --> 01:13:19,620
那么这给你带来了什么？

1297
01:13:21,270 --> 01:13:23,600
基本上，它保护了数据

1298
01:13:23,620 --> 01:13:25,580
你知道是否有人篡改了数据

1299
01:13:25,580 --> 01:13:30,620
所以真正了解哈希函数的唯一原因是

1300
01:13:30,620 --> 01:13:31,550
哦，我知道了

1301
01:13:31,620 --> 01:13:35,980
这是使数据防篡改的方法之一

1302
01:13:36,740 --> 01:13:37,560
请说

1303
01:13:37,560 --> 01:13:47,306
有一个问题，如果找到了理论上比 SHA-256 更好的哈希函数

1304
01:13:47,306 --> 01:13:50,988
如何将其实施到实际的比特币网络中

1305
01:13:50,988 --> 01:13:52,711
需要有一次共识...

1306
01:13:52,711 --> 01:13:53,879
所以...

1307
01:13:55,448 --> 01:14:01,287
比特币如何进行改变始终是一个挑战

1308
01:14:01,287 --> 01:14:04,000
因为它是一个去中心化的网络

1309
01:14:04,160 --> 01:14:09,110
所有去中心化网络都面临着一些治理挑战

1310
01:14:09,110 --> 01:14:12,560
治理挑战是如何进行软件更新

1311
01:14:12,560 --> 01:14:16,180
我们都知道在我们的笔记本电脑，iPhone 上

1312
01:14:16,830 --> 01:14:19,720
现在都可能正在进行软件更新

1313
01:14:19,720 --> 01:14:22,110
而我甚至不知道，对吧？

1314
01:14:22,130 --> 01:14:23,740
可能只是苹果发布了更新

1315
01:14:23,840 --> 01:14:26,110
我是说，谁知道他们在这里做什么，对吧？

1316
01:14:26,620 --> 01:14:29,050
还有 Uber, 这真的是我的最爱之一

1317
01:14:29,050 --> 01:14:31,410
谁知道手机里发生了什么

1318
01:14:31,420 --> 01:14:38,240
但商业企业、中央机关，有办法更新软件

1319
01:14:38,240 --> 01:14:40,500
我们可能会签署一些使用条款

1320
01:14:40,500 --> 01:14:42,240
允许他们这么做

1321
01:14:42,361 --> 01:14:45,410
在这样的去中心化网络中

1322
01:14:45,750 --> 01:14:47,630
必须达成共识

1323
01:14:48,090 --> 01:14:53,430
因此，真正更新为新的哈希函数的唯一方法

1324
01:14:54,260 --> 01:14:56,308
或者对于大多数其他事情来说

1325
01:14:56,308 --> 01:15:01,500
在本质上，是那些节点、软件的操作者

1326
01:15:01,510 --> 01:15:04,630
以集体共识的方式实现

1327
01:15:04,630 --> 01:15:06,352
因此，这是另一种方式

1328
01:15:06,352 --> 01:15:12,290
不仅是数据因为这些哈希函数而不可变

1329
01:15:13,560 --> 01:15:15,040
软件也是

1330
01:15:15,040 --> 01:15:18,430
这既有好处也有坏处

1331
01:15:18,580 --> 01:15:22,868
有人会说这是区块链的一个缺陷，有些人会说这是一个特点

1332
01:15:22,868 --> 01:15:25,960
你可以在学期的过程中做出自己的判断

1333
01:15:25,970 --> 01:15:33,445
但该软件比中央机构的软件更难更新

1334
01:15:33,445 --> 01:15:37,150
因为中央机构只是说... 他们只是弹出...

1335
01:15:38,320 --> 01:15:40,600
现在有时你必须点击更新

1336
01:15:41,360 --> 01:15:42,130
所以...

1337
01:15:42,670 --> 01:15:43,050
但是...

1338
01:15:43,870 --> 01:15:45,070
但别天真

1339
01:15:45,080 --> 01:15:48,520
不是每个软件都需要你点击

1340
01:15:48,890 --> 01:15:51,250
我的意思是，有些是自动发生的

1341
01:15:51,390 --> 01:15:53,440
但在这里你必须达成共识

1342
01:15:54,080 --> 01:15:56,720
我知道我没有回答你关于哈希函数的问题

1343
01:15:56,760 --> 01:15:59,305
但如果它是一个必须更新的哈希函数

1344
01:15:59,305 --> 01:16:01,820
并且每个人都说他们必须快速更新它

1345
01:16:03,890 --> 01:16:06,810
关于这个有一些有趣的争论

1346
01:16:06,810 --> 01:16:12,690
但你不需要回滚之前的 540,000 个区块

1347
01:16:12,700 --> 01:16:16,350
你可以对所有 540,000 个块进行哈希处理

1348
01:16:16,430 --> 01:16:22,461
从 180GB 缩减到一个 256 位，或者是另一种类型

1349
01:16:22,461 --> 01:16:26,530
然后你就可以拥有它，并且它是防篡改的

1350
01:16:27,170 --> 01:16:28,610
所以这些是关键的事情

1351
01:16:28,610 --> 01:16:30,050
这是我们所涵盖的内容

1352
01:16:30,050 --> 01:16:35,170
我们会在下周二介绍共识协议

1353
01:16:35,180 --> 01:16:37,890
我们在这里讨论了很多关于工作量证明的问题

1354
01:16:37,890 --> 01:16:41,570
因为每个人都将比特币视为工作量证明

1355
01:16:41,570 --> 01:16:45,851
但我们要讨论工作量证明、节点和原生货币

1356
01:16:45,851 --> 01:16:48,830
然后下周四，我们将讨论交易

1357
01:16:48,850 --> 01:16:51,410
重申，我会尝试分解这项技术

1358
01:16:52,660 --> 01:16:54,560
如果你想忘记这堂课

1359
01:16:54,560 --> 01:16:57,650
并且觉得，我的天啊，就像去看牙医一样

1360
01:16:59,020 --> 01:17:02,250
你可以告诉你的朋友你实际上了解一些密码学

1361
01:17:02,250 --> 01:17:04,350
它被称为加密货币

1362
01:17:04,690 --> 01:17:07,000
那么我们怎么能不了解密码学呢？

1363
01:17:07,070 --> 01:17:08,990
但基本上就是这三点

1364
01:17:09,000 --> 01:17:10,450
这是密码学

1365
01:17:10,460 --> 01:17:12,410
这是一个共识机制

1366
01:17:12,420 --> 01:17:14,079
以及交易

1367
01:17:14,079 --> 01:17:15,014
好吗？

1368
01:17:15,014 --> 01:17:18,880
密码学、共识机制、交易

1369
01:17:18,890 --> 01:17:19,900
我们会渡过难关

1370
01:17:19,900 --> 01:17:24,110
你会发现这对财务以及它是否有任何用例很重要

1371
01:17:24,130 --> 01:17:25,280
所以，谢谢

